import ast.AST.*;

import java.io.*;
import java.util.*;
import java.util.regex.*;

aspect JaddCodeGen {
  public void Grammar.abstractAncestors() {
    ASTDecl cl;
    IdDecl name;
    
    // Add ASTNode
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("ASTNode");
    cl.setIdDecl(name);
    cl.setFileName("ASTNode.ast");
    addTypeDecl(cl);
    
    // Add List
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("List");
    cl.setIdDecl(name);
    cl.setFileName("List.ast");
    addTypeDecl(cl);

    // Add Opt
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("Opt");
    cl.setIdDecl(name);
    cl.setFileName("Opt.ast");
    addTypeDecl(cl);
  }

  syn int ASTDecl.numNonNTAComponents() {
    int num = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        num++;
      }
    }
    return num;
  }

  syn int ASTDecl.numRegularChildren() {
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && !(c instanceof TokenComponent)) {
        i++;
      }
    }
    return i;
  }

  // Constructor to build trees bottom up
  public String ASTDecl.buildingConstructor() {
    // we only build constructors if there are components
    if(!getComponents().hasNext())
      return "";
    StringBuffer s = new StringBuffer();
    s.append(ind + "public #ID#.#ID#(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) s.append(", ");
        s.append(c.constrParmType() + " p" + i);
        i++;
      }
    }
    s.append(") {\n");
    if(ASTNode.block) s.append(ASTNode.blockBegin);
    // ES_2011-10-05: Code generation for incremental evaluation  
    if (ASTNode.incremental) s.append(genIncrementalConstructorStartConstruction());
    //
    i = 0;
    int j = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          s.append(ind(2) + "set" + t.getTokenId().getID() + "(p" + i + ");\n");
        }
        else {
          s.append(ind(2) + "setChild(p" + String.valueOf(i) + ", " + j + ");\n");
          j++;
        }
        i++;
      }
      else {
        if(c instanceof ListComponents) {
          s.append(ind(2) + "setChild(new List(), " + j + ");\n");
          j++;
        }
        else if(c instanceof OptionalComponent) {
          s.append(ind(2) + "setChild(new Opt(), " + j + ");\n");
          j++;
        }
        else if(c instanceof AggregateComponents) {
          s.append(ind(2) + "setChild(null, " + j + ");\n");
          j++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        s.append(ind(2) + "is$Final(java.lang.Integer.MAX_VALUE);\n");
      else {
        s.append(ind(2) + "is$Final(true);\n");
      }
    }
    // ES_2011-10-05: Code generation for incremental evaluation  
    if (ASTNode.incremental) s.append(genIncrementalConstructorEndConstruction());
    //
    // ES_2011-12-11: Code generation for incremental evaluation, track creation
    if (ASTNode.incremental) s.append(genIncrementalTrackCreation());
    //
    if(ASTNode.block) s.append(ASTNode.blockEnd);
    s.append(ind + "}\n");
    return s.toString().replaceAll("#ID#", name());
  }

  public String ASTDecl.buildingSymbolConstructor() {
    // we only build constructors if there are components ...
    if(!getComponents().hasNext())
      return "";
    // ... and one of these components is a string token component
    boolean stringArg = false;
    for(Iterator iter = getComponents(); !stringArg && iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
        stringArg = true;
    }
    if(!stringArg) return "";

    StringBuffer s = new StringBuffer();
    s.append(ind + "public #ID#.#ID#(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) s.append(", ");
        if(c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
          s.append("beaver.Symbol p" + i);
        else
          s.append(c.constrParmType() + " p" + i);
        i++;
      }
    }
    s.append(") {\n");
    if(ASTNode.block) s.append(ASTNode.blockBegin);
    // ES_2011-10-05: Code generation for incremental evaluation, construction 
    if (ASTNode.incremental) s.append(genIncrementalConstructorStartConstruction());
    //
    i = 0;
    int j = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          s.append(ind(2) + "set" + t.getTokenId().getID() + "(p" + i + ");\n");
        }
        else {
          s.append(ind(2) + "setChild(p" + String.valueOf(i) + ", " + j + ");\n");
          j++;
        }
        i++;
      }
      else {
        if(c instanceof ListComponents) {
          s.append(ind(2) + "setChild(new List(), " + j + ");\n");
          j++;
        }
        else if(c instanceof OptionalComponent) {
          s.append(ind(2) + "setChild(new Opt(), " + j + ");\n");
          j++;
        }
        else if(c instanceof AggregateComponents) {
          s.append(ind(2) + "setChild(null, " + j + ");\n");
          j++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        s.append(ind(2) + "is$Final(java.lang.Integer.MAX_VALUE);\n");
      else {
        s.append(ind(2) + "is$Final(true);\n");
      }
    }
    // ES_2011-10-05: Code generation for incremental evaluation, construction
    if (ASTNode.incremental) s.append(genIncrementalConstructorEndConstruction());
    //
    // ES_2011-12-11: Code generation for incremental evaluation, track creation
    if (ASTNode.incremental) s.append(genIncrementalTrackCreation());
    //
    if(ASTNode.block) s.append(ASTNode.blockEnd);
    s.append(ind + "}\n");
    return s.toString().replaceAll("#ID#", name());
  }

  // ES_2011-10-05: Code generation for incremental evaluation, enter construction
  public String ASTDecl.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-10-05: Code generation for incremental evaluation, end construction
  public String ASTDecl.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-12-11: Code generation for incremental evaluation, track creation
  public String ASTDecl.genIncrementalTrackCreation() {
    if (ASTNode.incrementalLevelNode) {
      return ind(2) + "state().addHandlerDepTo(handler);\n";
    }
    return "";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String ListComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String ListComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String OptionalComponent.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String OptionalComponent.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, enter construction
  public String AggregateComponents.genIncrementalConstructorStartConstruction() {
    return ind(2) + "state().enterConstruction();\n";
  }

  // ES_2011-11-23: Code generation for incremental evaluation, end construction
  public String AggregateComponents.genIncrementalConstructorEndConstruction() {
    return ind(2) + "state().exitConstruction();\n";
  }



  public void Grammar.genReset(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode$State.reset() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(circularEnabled) {
      stream.println(ind(2) + "IN_CIRCLE = false;");
      stream.println(ind(2) + "CIRCLE_INDEX = 1;"); // TOBBE
      stream.println(ind(2) + "CHANGE = false;");
      if(cacheCycle)
          stream.println(ind(2) + "LAST_CYCLE = false;");
      if(componentCheck) {
          stream.println(ind(2) + "circularEvalSet = " + ASTNode.createDefaultSet + ";");
          stream.println(ind(2) + "circularEvalStack = new java.util.Stack();");
      }
    }
    if(rewriteEnabled) {
      stream.println(ind(2) + "boundariesCrossed = 0;");
      genResetDuringCounters(stream);
      if(rewriteLimit > 0)
        stream.println(ind(2) + "debugRewrite = " + ASTNode.createDefaultMap + ";\n");
      if(stagedRewrites)
        stream.println(ind(2) + "rewritePhase = 1;\n");
    }
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
  }

  public void Grammar.jjtGenASTNode$State(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println("/**");
    stream.println(" * @apilevel internal");
    stream.println(" */");
    stream.println("static public class ASTNode$State {");
    if(circularEnabled) {
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean IN_CIRCLE = false;");
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public int CIRCLE_INDEX = 1;");
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean CHANGE = false;");
      if(cacheCycle) {
        stream.println("/**");
        stream.println(" * @apilevel internal");
        stream.println(" */");
        stream.println(ind + "public boolean LAST_CYCLE = false;");
      }
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean RESET_CYCLE = false;");

      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static public class CircularValue {");
      stream.println(ind(2) + "Object value;");
      stream.println(ind(2) + "int visited = -1;");
      stream.println(ind + "}");

      if(componentCheck) {
        stream.println(ind + "public " + ASTNode.typeDefaultSet + " circularEvalSet = " + ASTNode.createDefaultSet + ";");
        stream.println(ind + "public java.util.Stack circularEvalStack = new java.util.Stack();");

        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "static class CircularEvalEntry {");
        stream.println(ind(2) + "ASTNode node;");
        stream.println(ind(2) + "String attrName;");
        stream.println(ind(2) + "Object parameters;");

        stream.println(ind(2) + "public CircularEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(3) + "this.node = node;");
        stream.println(ind(3) + "this.attrName = attrName;");
        stream.println(ind(3) + "this.parameters = parameters;");
        stream.println(ind(2) + "}");

        stream.println(ind(2) + "public boolean equals(Object rhs) {");
        stream.println(ind(3) + "CircularEvalEntry s = (CircularEvalEntry) rhs;");
        stream.println(ind(3) + "if (parameters == null && s.parameters == null)");
        stream.println(ind(4) + "return node == s.node && attrName.equals(s.attrName);");
        stream.println(ind(3) + "else if (parameters != null && s.parameters != null)");
        stream.println(ind(4) + "return node == s.node && attrName.equals(s.attrName) && parameters.equals(s.parameters);");
        stream.println(ind(3) + "else");
        stream.println(ind(4) + "return false;");
        stream.println(ind(2) + "}");

        stream.println(ind(2) + "public int hashCode() {");
        stream.println(ind(3) + "return node.hashCode();");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");

        stream.println(ind + "public void addEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(2) + "circularEvalSet.add(new CircularEvalEntry(node,attrName,parameters));");
        stream.println(ind + "}");

        stream.println(ind + "public boolean containsEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(2) + "return circularEvalSet.contains(new CircularEvalEntry(node,attrName,parameters));");
        stream.println(ind + "}");

        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "static class CircularStackEntry {");
        stream.println(ind(2) + "" + ASTNode.typeDefaultSet + " circularEvalSet;");
        stream.println(ind(2) + "boolean changeValue;");

        stream.println(ind(2) + "public CircularStackEntry(" + ASTNode.typeDefaultSet + " set, boolean change) {");
        stream.println(ind(3) + "circularEvalSet = set;");
        stream.println(ind(3) + "changeValue = change;");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");

        stream.println(ind + "public void pushEvalStack() {");
        stream.println(ind(2) + "circularEvalStack.push(new CircularStackEntry(circularEvalSet, CHANGE));");
        stream.println(ind(2) + "circularEvalSet = " + ASTNode.createDefaultSet + ";");
        stream.println(ind(2) + "CHANGE = false;");
        stream.println(ind + "}");

        stream.println(ind + "public void popEvalStack() {");
        stream.println(ind(2) + "CircularStackEntry c = (CircularStackEntry) circularEvalStack.pop();");
        stream.println(ind(2) + "circularEvalSet = c.circularEvalSet;");
        stream.println(ind(2) + "CHANGE = c.changeValue;");
        stream.println(ind + "}");

      }
    }
    if(rewriteEnabled) {
      stream.println(ind + "public static final int REWRITE_CHANGE = 1;");
      stream.println(ind + "public static final int REWRITE_NOCHANGE = 2;");
      stream.println(ind + "public static final int REWRITE_INTERRUPT = 3;");
      if(rewriteLimit > 0) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public java.util.HashMap debugRewrite = " + ASTNode.createDefaultMap + ";\n");
      }
      stream.println(ind + "public int boundariesCrossed = 0;\n");
      if(stagedRewrites)
        stream.println(ind + "public int rewritePhase = 1;");
      // state code
      stream.println(ind + "private int[] stack;");
      stream.println(ind + "private int pos;");
      stream.println(ind + "public ASTNode$State() {");
      stream.println(ind(3) + "stack = new int[64];");
      stream.println(ind(3) + "pos = 0;");
      stream.println(ind + "}");
      stream.println(ind + "private void ensureSize(int size) {");
      stream.println(ind(3) + "if(size < stack.length)");
      stream.println(ind(4) + "return;");
      stream.println(ind(3) + "int[] newStack = new int[stack.length * 2];");
      stream.println(ind(3) + "System.arraycopy(stack, 0, newStack, 0, stack.length);");
      stream.println(ind(3) + "stack = newStack;");
      stream.println(ind + "}");
      stream.println(ind + "public void push(int i) {");
      stream.println(ind(2) + "ensureSize(pos+1);");
      stream.println(ind(2) + "stack[pos++] = i;");
      stream.println(ind + "}");
      stream.println(ind + "public int pop() {");
      stream.println(ind(2) + "return stack[--pos];");
      stream.println(ind + "}");
      stream.println(ind + "public int peek() {");
      stream.println(ind(2) + "return stack[pos-1];");
      stream.println(ind + "}");
    }

    if(j2me) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class HashtableBasedSet  {");
      stream.println(ind(2) + "public HashtableBasedSet(int initialCapacity) {");
      stream.println(ind(3) + "map = new java.util.Hashtable(initialCapacity);");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "private java.util.Hashtable map;");
      stream.println(ind(2) + "private static final Object PRESENT = new Object();");
      stream.println(ind(2) + "public java.util.Enumeration elements() { return map.keys(); }");
      stream.println(ind(2) + "public int size() { return map.size(); }");
      stream.println(ind(2) + "public boolean isEmpty() { return map.isEmpty(); }");
      stream.println(ind(2) + "public boolean contains(Object o) { return map.containsKey(o); }");
      stream.println(ind(2) + "public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
      stream.println(ind(2) + "public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
      stream.println(ind(2) + "public void clear() { map.clear(); }");
      stream.println(ind + "}");
    }
    else if(deterministic) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class IdentityHashSet extends java.util.LinkedHashSet {");
      stream.println(ind(2) + "public IdentityHashSet(int initialCapacity) { super(initialCapacity); }");
      stream.println(ind(2) + "/**");
      stream.println(ind(2) + " * @apilevel internal");
      stream.println(ind(2) + " */");
      stream.println(ind(2) + "public java.util.Iterator iterator() {");
      stream.println(ind(3) + "final java.util.Iterator i = super.iterator();");
      stream.println(ind(3) + "return new java.util.Iterator() {");
      stream.println(ind(4) + "public boolean hasNext() { return i.hasNext(); }");
      stream.println(ind(4) + "public Object next() { return ((Wrapper)i.next()).o; }");
      stream.println(ind(4) + "public void remove() { i.remove(); }");
      stream.println(ind(3) + "};");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "public boolean contains(Object o) { return super.contains(wrap(o)); }");
      stream.println(ind(2) + "public boolean add(Object o) { return super.add(wrap(o)); }");
      stream.println(ind(2) + "public boolean remove(Object o) { return super.remove(wrap(o)); }");
      stream.println(ind(2) + "private Wrapper wrap(Object o) { return new Wrapper(o); }");
      stream.println(ind(2) + "/**");
      stream.println(ind(2) + " * @apilevel internal");
      stream.println(ind(2) + " */");
      stream.println(ind(2) + "private static class Wrapper {");
      stream.println(ind(3) + "private Object o;");
      stream.println(ind(3) + "private Wrapper(Object o) { this.o = o; }");
      stream.println(ind(3) + "public boolean equals(Object other) { return other instanceof Wrapper && ((Wrapper)other).o == o; }");
      stream.println(ind(3) + "public int hashCode() { return System.identityHashCode(o); }");
      stream.println(ind(2) + "}");
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class IdentityHashSet extends java.util.AbstractSet implements java.util.Set {");
      stream.println(ind(2) + "public IdentityHashSet(int initialCapacity) {");
      stream.println(ind(3) + "map = new java.util.IdentityHashMap(initialCapacity);");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "private java.util.IdentityHashMap map;");
      stream.println(ind(2) + "private static final Object PRESENT = new Object();");
      stream.println(ind(2) + "public java.util.Iterator iterator() { return map.keySet().iterator(); }");
      stream.println(ind(2) + "public int size() { return map.size(); }");
      stream.println(ind(2) + "public boolean isEmpty() { return map.isEmpty(); }");
      stream.println(ind(2) + "public boolean contains(Object o) { return map.containsKey(o); }");
      stream.println(ind(2) + "public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
      stream.println(ind(2) + "public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
      stream.println(ind(2) + "public void clear() { map.clear(); }");
      stream.println(ind + "}");
    }

    // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
    if (ASTNode.incremental) jjtGenIncrementalEvaluationStack(stream);

    stream.println("}"); // End ASTNode$State
  }

  // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
  public void Grammar.jjtGenIncrementalEvaluationStack(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind + "public int IN_COMPUTATION = 0;");
    }
    stream.println(ind + "protected java.util.Stack handlerAttrStack = new java.util.Stack();");
    stream.println(ind + "protected java.util.Stack handlerRewriteStack = new java.util.Stack();");
    stream.println(ind + "public void addHandlerDepTo(ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL && !IN_REWRITE_EVAL || handler == null) {");
    stream.println(ind(3) +   "return;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "java.util.Stack handlerStack = handlerAttrStack;");
    stream.println(ind(2) + "if (IN_REWRITE_EVAL) ");
    stream.println(ind(3) +   "handlerStack = handlerRewriteStack;");
    stream.println(ind(2) + "if (!handlerStack.isEmpty()) {");
    stream.println(ind(3) +   "//throw new Error(\"Handler stack is empty at addition of dependency!\");");
    stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)handlerStack.peek();");
    stream.println(ind(3) +   "handler.addDependant(top);");
    stream.println(ind(2) + "}");
    stream.println(ind + "}");
    stream.println(ind + "public boolean IN_ATTR_STORE_EVAL = false;");
    stream.println(ind + "public void enterAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = true;");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack enter: \" + handler.fAttrID);");
    stream.println(ind(3) +   "pushHandler(handlerAttrStack, handler);");
    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "popHandler(handlerAttrStack, handler);");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack exit: \" + handler.fAttrID);");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = !handlerAttrStack.isEmpty();");
    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public boolean IN_REWRITE_EVAL = false;");
    stream.println(ind + "public void enterRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "IN_REWRITE_EVAL = true;");
    stream.println(ind(2) + "pushHandler(handlerRewriteStack, handler);");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "if (IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "popHandler(handlerRewriteStack, handler);");
    stream.println(ind(3) +   "IN_REWRITE_EVAL = !handlerRewriteStack.isEmpty();");
    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public boolean IN_CONSTRUCTION = false;");
    stream.println(ind + "private int inc_constructionCount = 0;");
    stream.println(ind + "public void enterConstruction() {"); 
    stream.println(ind(2) + "IN_CONSTRUCTION = true;");
    stream.println(ind(2) + "inc_constructionCount++;");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitConstruction() {"); 
    stream.println(ind(2) + "inc_constructionCount--;");
    stream.println(ind(2) + "if (inc_constructionCount == 0)");
    stream.println(ind(3) +   "IN_CONSTRUCTION = false;");
    stream.println(ind + "}"); 
    stream.println(ind + "protected void pushHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "stack.push(handler);");
    stream.println(ind + "}");        
    stream.println(ind + "protected ASTNode$DepGraphNode popHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (stack.isEmpty())");
    stream.println(ind(3) +   "throw new Error(\"Handler stack is empty at exit!\");");
    stream.println(ind(2) + "ASTNode$DepGraphNode h = (ASTNode$DepGraphNode)stack.pop();");
    stream.println(ind(2) + "if (h != handler)");
    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop!\");");
//    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop! [\" + handler.fAttrID + \"]\");");
    stream.println(ind(2) + "return h;");
    stream.println(ind + "}");
  }

  public void ASTDecl.jjtGenASTNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithCircularEnabled = " + ASTNode.circularEnabled + ";");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithCacheCycle = " + ASTNode.cacheCycle + ";");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithComponentCheck = " + ASTNode.componentCheck + ";");
    if(ASTNode.noStatic) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode$State ASTNode.state = null;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode$State ASTNode.state() {");
      stream.println(ind(2) + "if(state == null) {");
      stream.println(ind(3) + "if(parent == null) {");
      stream.println(ind(4) + "state = new ASTNode$State();");
      if(ASTNode.debugMode) {
        // check if a new state object is created for a node that is not a root node
        StringBuffer s = new StringBuffer();
        s.append("if(");
        boolean first = true;
        for(Iterator iter = env().roots().iterator(); iter.hasNext(); ) {
          ASTDecl root = (ASTDecl)iter.next();
          if(!first)
            s.append(" && ");
          first = false;
          s.append("!(this instanceof " + root.name() + ")");
        }
        s.append(") throw new RuntimeException(\"Trying to evaluate state in a node which is not attached to the main tree\");");
        stream.println(s.toString());
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "else {");
      stream.println(ind(4) + "tate = parent.state();");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return state;");
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected static ASTNode$State ASTNode.state = new ASTNode$State();");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode$State ASTNode.state() { return state; }");
    }


    if(rewriteEnabled) {
      if(rewriteLimit > 0) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.debugRewrite(String info) {");
        stream.println(ind(2) + "if(!parent.is$Final()) return;");
        stream.println(ind(2) + "java.util.ArrayList key = new java.util.ArrayList(2);");
        stream.println(ind(2) + "key.add(getParent());");
        stream.println(ind(2) + "key.add(new Integer(getParent().getIndexOfChild(this)));");
        stream.println(ind(2) + "java.util.ArrayList list;");
        stream.println(ind(2) + "if(state().debugRewrite.containsKey(key))");
        stream.println(ind(3) + "list = (java.util.ArrayList)state().debugRewrite.get(key);");
        stream.println(ind(2) + "else {");
        stream.println(ind(3) + "list = new java.util.ArrayList();");
        stream.println(ind(3) + "state().debugRewrite.put(key, list);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "list.add(info);");
        stream.println(ind(2) + "if(list.size() > " + rewriteLimit + ") {");
        stream.println(ind(3) + "StringBuffer buf = new StringBuffer(\"Iteration count exceeded for rewrite:\");");
        stream.println(ind(3) + "for(java.util.Iterator iter = list.iterator(); iter.hasNext(); ) buf.append(\"\\n\" + iter.next());");
        stream.println(ind(3) + "throw new RuntimeException(buf.toString());");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.debugRewriteRemove() {");
        stream.println(ind(2) + "java.util.ArrayList key = new java.util.ArrayList(2);");
        stream.println(ind(2) + "key.add(getParent());");
        stream.println(ind(2) + "key.add(new Integer(getParent().getIndexOfChild(this)));");
        stream.println(ind(2) + "state().debugRewrite.remove(key);");
        stream.println(ind + "}\n");
      }
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean ASTNode.in$Circle = false;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean ASTNode.in$Circle() { return in$Circle; }");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.in$Circle(boolean b) { in$Circle = b; }");
      if(ASTNode.stagedRewrites) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public int ASTNode.is$Final = 0;");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final() { return is$Final >= state().rewritePhase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.is$Final(int phase) { is$Final = phase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.enterRewritePhase(int phase) { state().rewritePhase = phase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.inRewritePhase(int phase) { return state().rewritePhase >= phase; }");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final = false;");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final() { return is$Final; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.is$Final(boolean b) { is$Final = b; }");
      }
      if(ASTNode.java5) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "@SuppressWarnings(\"cast\") public T ASTNode.getChild(int i) {");
        // ES_2011-12-12: Code generation for incremental evaluation, crossing between regions
        if (ASTNode.incrementalLevelRegion) jjtGenIncrementalTrackRewrite9(stream);
        else 
        //
        stream.println(ind(2) + "return (T)ASTNode.getChild(this, i);");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public ASTNode ASTNode.getChild(int i) {");
        // ES_2011-12-12: Code generation for incremental evaluation, crossing between regions
        if (ASTNode.incrementalLevelRegion) jjtGenIncrementalTrackRewrite10(stream);
        else 
        //
        stream.println(ind(2) + "return ASTNode.getChild(this, i);");
        stream.println(ind + "}");
      }
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public static ASTNode ASTNode.getChild(ASTNode that, int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      stream.println(ind(2) + "ASTNode node = that.getChildNoTransform(i);");
      stream.println(ind(2) + "if(node.is$Final()) {");
      // ES_2011-10-05: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite4(stream);
      //
      stream.println(ind(3) +   "return node;");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "if(!node.mayHaveRewrite()) {");
      if(ASTNode.stagedRewrites)
        stream.println(ind(3) + "node.is$Final(that.is$Final);");
      else
        stream.println(ind(3) + "node.is$Final(that.is$Final());");
      // ES_2011-10-05: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite4(stream);
      //
      stream.println(ind(3) + "return node;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if(!node.in$Circle()) {");
      // ES_2011-09-26: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite1(stream);
      //
      // ES_2011-10-10: Code generation for full flush
      if (ASTNode.fullFlush) jjtGenFullFlush1(stream);
      //
      stream.println(ind(3) + "int rewriteState;");
      stream.println(ind(3) + "int num = that.state().boundariesCrossed;");
      stream.println(ind(3) + "do {");
      stream.println(ind(4) + "that.state().push(ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(4) + "ASTNode oldNode = node;");
      stream.println(ind(4) + "oldNode.in$Circle(true);");
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite5(stream);
      //
      stream.println(ind(4) + "node = node.rewriteTo();");
      stream.println(ind(4) + "if(node != oldNode) {");
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite7(stream);
      //
      stream.println(ind(5) + "that.setChild(node, i);");
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite8(stream);
      //
      stream.println(ind(4) + "}");
      stream.println(ind(4) + "oldNode.in$Circle(false);");
      stream.println(ind(4) + "rewriteState = that.state().pop();");
      // ES_2011-09-30: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite3(stream);
      //
      // ES_2011-10-10: Code generation for full flush
      if (ASTNode.fullFlush) jjtGenFullFlush2(stream);
      //
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite6(stream);
      //
      stream.println(ind(3) + "} while(rewriteState == ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(3) + "if(rewriteState == ASTNode$State.REWRITE_NOCHANGE && that.is$Final()) {");
      if(ASTNode.stagedRewrites)
        stream.println(ind(4) + "node.is$Final(that.state().rewritePhase);");
      else
        stream.println(ind(4) + "node.is$Final(true);");
      stream.println(ind(4) + "that.state().boundariesCrossed = num;");
      if(rewriteLimit > 0)
        stream.println(ind(4) + "node.debugRewriteRemove();");
      stream.println(ind(3) + "}");
      // ES_2011-09-30: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite2(stream);
      //
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "else if(that.is$Final() != node.is$Final()) that.state().boundariesCrossed++;");
      // ES_2011-09-26: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite4(stream);
      //
      // ES_2011-12-12: Code generation for incremental evaluation, rewrites 
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite11(stream);
      //
      stream.println(ind(2) + "return node;");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    else {
      if(ASTNode.java5) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "@SuppressWarnings(\"cast\")");
        stream.println(ind + "public T ASTNode.getChild(int i) {");
        // ES_2011-09-20: Code generation for incremental evaluation
        if (ASTNode.incremental) {
          stream.println(ind(2) + "T child = (T)getChildNoTransform(i);");
          jjtGenIncrementalTrackGetChildNoTransform(stream);
          stream.println(ind(2) + "return child;");        
        } else 
        //
        stream.println(ind(2) + "return (T)getChildNoTransform(i);");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public ASTNode ASTNode.getChild(int i) {");
        // ES_2011-09-20: Code generation for incremental evaluation
        if (ASTNode.incremental) {
          stream.println(ind(2) + "ASTNode child = getChildNoTransform(i);");
          jjtGenIncrementalTrackGetChildNoTransform(stream);
          stream.println(ind(2) + "return child;");        
        } else 
        //
        stream.println(ind(2) + "return getChildNoTransform(i);");
        stream.println(ind + "}");
      }
    }
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "private int ASTNode.childIndex;");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public int ASTNode.getIndexOfChild(ASTNode node) {");
    stream.println(ind(2) + "if(node != null && node.childIndex < getNumChildNoTransform() && node == getChildNoTransform(node.childIndex))");
    stream.println(ind(3) + "return node.childIndex;");
    stream.println(ind(2) + "for(int i = 0; i < getNumChildNoTransform(); i++)");
    stream.println(ind(3) + "if(getChildNoTransform(i) == node) {");
    stream.println(ind(4) + "node.childIndex = i;");
    stream.println(ind(4) + "return i;");
    stream.println(ind(3) + "}");
    stream.println(ind(2) + "return -1;");
    stream.println(ind + "}\n");
    if(ASTNode.java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.addChild(T node) {");
    } else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.addChild(ASTNode node) {");
    }
    stream.println(ind(2) + "setChild(node, getNumChildNoTransform());");
    stream.println(ind + "}");


    if(ASTNode.java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "@SuppressWarnings(\"cast\")");
      // ES_2011-12-13: Code generation for incremental evaluation    
      if (ASTNode.incremental) jjtGenIncrementalTrackGetChildNoTransformName2(stream);
      else 
      //
      stream.println(ind + "public final T ASTNode.getChildNoTransform(int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      // ES_2011-09-20: Code generation for incremental evaluation
      if (ASTNode.incremental) {
        stream.println(ind(2) + "T child = (T)children[i];");
        jjtGenIncrementalTrackGetChildNoTransform(stream);
        stream.println(ind(2) + "return child;");        
      } else 
      //
      stream.println(ind(2) + "return (T)children[i];");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      // ES_2011-12-13: Code generation for incremental evaluation    
      if (ASTNode.incremental) jjtGenIncrementalTrackGetChildNoTransformName1(stream);
      else 
      //
      stream.println(ind + "public final ASTNode ASTNode.getChildNoTransform(int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      // ES_2011-09-20: Code generation for incremental evaluation
      if (ASTNode.incremental) {
        stream.println(ind(2) + "ASTNode child = (ASTNode)children[i];");
        jjtGenIncrementalTrackGetChildNoTransform(stream);
        stream.println(ind(2) + "return child;");        
      } else 
      //
      stream.println(ind(2) + "return (ASTNode)children[i];");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren;"); // added
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren() {");
    // ES_2011-09-20: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
    stream.println(ind(2) + "return numChildren;");
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public int ASTNode.getNumChild() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    // ES_2011-09-20: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
    stream.println(ind(2) + "return numChildren();");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public final int ASTNode.getNumChildNoTransform() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    stream.println(ind(2) + "return numChildren();");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.setChild(ASTNode node, int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(debugMode)
      stream.println(ind(2) + "debugNodeAttachment(node);");
    // ES_2011-10-06: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild1(stream);
    //
    stream.println(ind + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[i + 1];");
    // ES_2011-10-06: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild2(stream);
    //
    stream.println(ind + "} else if (i >= children.length) {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[i << 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, children.length);");
    stream.println(ind(3) + "children = c;");
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild3(stream);
    //
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.fullFlush) jjtGenFullFlushSetChild1(stream);
    //
    stream.println(ind(2) + "}");
    // ES_2011-11-28: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild5(stream);
    //
    stream.println(ind(2) + "children[i] = node;");
    stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild4(stream);
    //
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.fullFlush) jjtGenFullFlushSetChild2(stream);
    //
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.insertChild(ASTNode node, int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(debugMode)
      stream.println(ind(2) + "debugNodeAttachment(node);");
    // ES_2011-10-06: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild3(stream);
    //
    stream.println(ind(2) + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[i + 1];");
    stream.println(ind(3) + "children[i] = node;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild1(stream);
    //
    stream.println(ind(2) + "} else {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[children.length + 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, i);");
    stream.println(ind(3) + "c[i] = node;");
    stream.println(ind(3) + "if(i < children.length)");
    stream.println(ind(4) + "System.arraycopy(children, i, c, i+1, children.length-i);");
    stream.println(ind(3) + "children = c;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild2(stream);
    //
    // ES_2011-10-10: Code generation for full flush
    if (ASTNode.fullFlush) jjtGenFullFlushInsertChild1(stream);
    //
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "numChildren++;");
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.removeChild(int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    stream.println(ind(2) + "if(children != null) {");
    // ES_2011-10-06: Code generation for incremental evaluation, remove child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeRemoveChild1(stream);
    //
    stream.println(ind(3) + "ASTNode child = (ASTNode)children[i];");
    stream.println(ind(3) + "if(child != null) {");
    // ES_2011-11-28: Code generation for incremental evaluation, remove child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeRemoveChild3(stream);
    // 
    stream.println(ind(4) + "child.parent = null;");
    stream.println(ind(4) + "child.childIndex = -1;");
    stream.println(ind(3) + "}");
    stream.println(ind(3) + "System.arraycopy(children, i+1, children, i, children.length-i-1);");
    stream.println(ind(3) + "children[children.length-1] = null;");
    stream.println(ind(3) + "numChildren--;");
    // ES_2011-10-06: Code generation for incremental evaluation, remove child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeRemoveChild2(stream);
    //
    // ES_2011-10-06: Code generation for full flush, remove child
    if (ASTNode.fullFlush) jjtGenFullFlushRemoveChild1(stream);
    //
    stream.println(ind(2) + "}");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public ASTNode ASTNode.getParent() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(rewriteEnabled) {
      stream.println(ind(2) + "if(parent != null && ((ASTNode)parent).is$Final() != is$Final()) {");
      stream.println(ind(3) + "state().boundariesCrossed++;");
      stream.println(ind(2) + "}");
    }
    // ES_2011-09-20: Code generation for incremental evaluation, track getParent
    if (ASTNode.incremental) jjtGenIncrementalTrackGetParent(stream);
    //
    stream.println(ind(2) + "return (ASTNode)parent;");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.setParent(ASTNode node) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    // ES_2011-10-10: Code generation for incremental evaluation, set parent
    if (ASTNode.incremental) jjtGenIncrementalSetParent(stream);
    //
    stream.println(ind(2) + "parent = node;");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    if(!jjtree) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode ASTNode.parent;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode[] ASTNode.children;");
    }
    if(debugMode) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected boolean ASTNode.debugNodeAttachmentIsRoot() { return false; }");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "private static void ASTNode.debugNodeAttachment(ASTNode node) {");
      stream.println(ind(2) + "if(node == null) throw new RuntimeException(\"Trying to assign null to a tree child node\");");
      stream.println(ind(2) + "while(node != null && !node.debugNodeAttachmentIsRoot()) {");
      if(rewriteEnabled)
        stream.println(ind(3) + "if(node.in$Circle()) return;");
      stream.println(ind(3) + "ASTNode parent = (ASTNode)node.parent;");
      stream.println(ind(3) + "if(parent != null && parent.getIndexOfChild(node) == -1) return;");
      stream.println(ind(3) + "node = parent;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if(node == null) return;");
      stream.println(ind(2) + "throw new RuntimeException(\"Trying to insert the same tree at multiple tree locations\");");
      stream.println(ind + "}");
    }
  }


  // ES_2011-10-10: Code generation for full flush, creating initial copy store
  public void ASTDecl.jjtGenFullFlush1(PrintWriter stream) {
    stream.println(ind(2) + "if(that.init_children == null) {");
    stream.println(ind(3) +   "that.init_children = new ASTNode[that.children.length];");
    stream.println(ind(3) +   "that.rewritten_children = new boolean[that.children.length];");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if(!node.inc_hasEnclosingRewrittenNode()) {");
    stream.println(ind(3) +   "that.init_children[i] = node.fullCopy();");
    stream.println(ind(2) + "}");
  }
  // ES_2011-10-10: Code generation for full flush, storing initial copy setting rewrite to true
  public void ASTDecl.jjtGenFullFlush2(PrintWriter stream) {
    stream.println(ind(4) + "if (rewriteState == ASTNode$State.REWRITE_CHANGE) {");
    stream.println(ind(5) +   "that.rewritten_children[i] = true;");
    stream.println(ind(5) +   "that.init_children[i] = initial;");
    stream.println(ind(4) + "}");
  }
  
  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite5(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "that.state().enterRewriteEval(node.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      //stream.println(ind(4) + "that.state().IN_REWRITE_EVAL = true;");
      stream.println(ind(4) + "that.state().IN_COMPUTATION++;");
    }
  }
  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite6(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) + "that.state().exitRewriteEval(oldNode.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(4) + "that.state().IN_COMPUTATION--;");
      //stream.println(ind(4) + "that.state().IN_REWRITE_EVAL = false;");
    }
  }

  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite7(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(5) + "ASTNode initial = that.init_children[i];");
      stream.println(ind(5) + "oldNode.handler.clearDependencies();");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(5) + "ASTNode initial = that.init_children[i];");
      stream.println(ind(5) + "if (node.isRegionRoot()) {");
      stream.println(ind(6) +   "node.handler().addSetsFrom(oldNode.handler());");
      stream.println(ind(5) + "}");
      // stream.println(ind(5) + "oldNode.handler().clearDependencies();");
    }
  }
  // ES_2011-12-10: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite8(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
      stream.println(ind(5) + "that.init_children[i] = initial;");
    }
  }

  // ES_2011-12-12_ Code generation for incremental evalutaion, crossing between regions
  public void ASTDecl.jjtGenIncrementalTrackRewrite9(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "ASTNode child = ASTNode.getChild(this, i);");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
        stream.println(ind(3) +   "child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return (T)child;");
      } else {
        stream.println(ind(2) + "return (T)ASTNode.getChild(this, i);");
      }
    }
  }
  // ES_2011-12-12_ Code generation for incremental evalutaion, crossing between regions
  public void ASTDecl.jjtGenIncrementalTrackRewrite10(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "ASTNode child = ASTNode.getChild(this, i);");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0) {");
        stream.println(ind(3) +   "child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return child;");
      }
    }
  }



  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite1(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(2) + "if(that.init_children == null) {");
    stream.println(ind(3) +   "that.init_children = new ASTNode[that.children.length];");
    stream.println(ind(3) +   "that.rewritten_children = new boolean[that.children.length];");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if(!node.inc_hasEnclosingRewrittenNode()) {");
    stream.println(ind(3) +   "that.init_children[i] = node.fullCopy();");
    stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "that.state().enterRewriteEval(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().enterRewriteEval(that.getChild_handler);");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "that.state().exitRewriteEval(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().exitRewriteEval(that.getChild_handler);");
    }
  }
  // ES_2011-09-30: Code generation for incremental evaluation, tracking rewrites
  public void ASTDecl.jjtGenIncrementalTrackRewrite3(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
    stream.println(ind(4) + "if (rewriteState == ASTNode$State.REWRITE_CHANGE) {");
    stream.println(ind(5) +   "that.rewritten_children[i] = true;");
    stream.println(ind(4) + "}");
    }
  }
  // ES_2011-10-05: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite4(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (that.getChild_handler[i] == null) {");
      stream.println(ind(4) +   "that.getChild_handler[i] = new ASTNode$DepGraphNode(that, \"getChild\", new Integer(i));");
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "that.state().addHandlerDepTo(that.getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "that.state().addHandlerDepTo(that.getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  that.state().addHandlerDepTo(node.handler);");
      stream.println(ind(2) + "}");
    }
  }
  // ES_2011-12-12: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackRewrite11(PrintWriter stream) {
    if (ASTNode.incrementalLevelRegion) {
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // The possibility of a dependency requires one.
      stream.println(ind(2) + "if (node != null && node.isRegionRoot()) {");
      stream.println(ind(3) +   "that.handler().addDependant(node.handler());");
      stream.println(ind(3) +   "node.handler().addDependant(that.handler());");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (node != null) {");
      stream.println(ind(3) + "  that.state().addHandlerDepTo(node.handler);");
      // rewrite is evaluated in "that" and may use attributes in that node, but this is not tracked. 
      // The possibility of a dependency requires one.
      stream.println(ind(3) + "  that.handler.addDependant(node.handler);");
      stream.println(ind(2) + "}");
    }
  }


  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName1(PrintWriter stream) {
      stream.println(ind + "public ASTNode ASTNode.getChildNoTransform(int i) {");
  }
  // ES_2011-12-13: Code generation for incremental evaluation, name getChildNoTransform
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransformName2(PrintWriter stream) {
      stream.println(ind + "public T ASTNode.getChildNoTransform(int i) {");
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackGetChildNoTransform(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler[i] == null) {");
      stream.println(ind(3) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (child != null)");
      stream.println(ind(3) + "  state().addHandlerDepTo(child.handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child != null) {");
        stream.println(ind(3) + "  child.handler().addDependant(handler);");
        stream.println(ind(2) + "}");
      }
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking getParent
  public void ASTDecl.jjtGenIncrementalTrackGetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getParent_handler);");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null)");
      stream.println(ind(3) +   "state().addHandlerDepTo(((ASTNode)parent).handler);");
    }
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && parent != null)");
        stream.println(ind(3) +   "parent.handler().addDependant(handler);");
      }
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking numChildren
  public void ASTDecl.jjtGenIncrementalTrackNumChild(PrintWriter stream) {  
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(numChildren_handler);");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set parent
  public void ASTDecl.jjtGenIncrementalSetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "getParent_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler.flushRegion();");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "parent.handler().flushRegion();");
      stream.println(ind(2) + "}");
    }
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (parent != null) {");
    stream.println(ind(3) +   "int index = parent.getIndexOfChild(this);");
    stream.println(ind(3) +   "if (index >= 0)");
    stream.println(ind(4) +     "parent.removeChild(index);");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (node != null) {");
    stream.println(ind(3) +   "inc_changeState(node.inc_state);");
    stream.println(ind(2) + "} else inc_changeState(inc_GARBAGE);");
  }

  // ES_2011-10-10: Code generation for full flush, set child 1
  public void ASTDecl.jjtGenFullFlushSetChild1(PrintWriter stream) {
    stream.println(ind(2) + "if (init_children != null) {");
    stream.println(ind(3) +   "ASTNode d[] = new ASTNode[i << 1];");
    stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
    stream.println(ind(3) +   "init_children = d;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "boolean[] b = new boolean[i << 1];");
    stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
    stream.println(ind(3) +   "rewritten_children = b;");
    stream.println(ind(2) + "}");
  }
  // ES_2011-10-10: Code generation for full flush, set child 2
  public void ASTDecl.jjtGenFullFlushSetChild2(PrintWriter stream) {
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "rewritten_children[i] = false;"); 
    stream.println(ind(2) + "}");   
  }

  // ES_2011-10-10: Code generation for full flush, insert child 1
  public void ASTDecl.jjtGenFullFlushInsertChild1(PrintWriter stream) {
    stream.println(ind(2) + "if (init_children != null) {");
    stream.println(ind(3) +   "ASTNode d[] = new ASTNode[init_children.length + 1];");
    stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
    stream.println(ind(3) +   "if (i < init_children.length) {");
    stream.println(ind(4) +     "System.arraycopy(init_children, i, d, i+1, init_children.length - i);");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "init_children = d;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "if (rewritten_children != null) {");
    stream.println(ind(3) +   "boolean b[] = new boolean[rewritten_children.length + 1];");
    stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
    stream.println(ind(3) +   "if (i < rewritten_children.length) {");
    stream.println(ind(4) +     "System.arraycopy(rewritten_children, i, b, i+1, rewritten_children.length - i);");
    stream.println(ind(3) +   "}");
    stream.println(ind(3) +   "rewritten_children = b;");
    stream.println(ind(2) + "}");
  }

  // ES_2011-10-10: Code generation for full flush, remove child 1
  public void ASTDecl.jjtGenFullFlushRemoveChild1(PrintWriter stream) {
    stream.println(ind(3) + "if (init_children != null) {");
    stream.println(ind(4) +   "System.arraycopy(init_children, i+1, init_children, i, init_children.length-i-1);");
    stream.println(ind(3) + "}");      
    stream.println(ind(3) + "if (rewritten_children != null) {");
    stream.println(ind(4) +   "System.arraycopy(rewritten_children, i+1, rewritten_children, i, rewritten_children.length-i-1);");
    stream.println(ind(3) + "}");
  }



  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 1
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify current child
    stream.println(ind(3) +   "if (children != null && i < children.length && children[i] != null) {");
    stream.println(ind(4) +     "children[i].inc_notifyForRemove();");
    //if (ASTNode.incrementalDebug) stream.println(ind(4) +     "children[i].inc_clearDepsInTree();");
    stream.println(ind(3) +   "}");
    // notify dependencies
    if (ASTNode.incrementalLevelParam) {  
      // notify empty
      stream.println(ind(3) +   "if (children == null) {");
      stream.println(ind(4) +     "numChildren_handler.notifyDependencies();");
      // notify add
      stream.println(ind(3) +   "} else if (i >= numChildren) {");
      stream.println(ind(4) +     "numChildren_handler.notifyDependencies();");
      stream.println(ind(4) +     "if (i > 0 && getChild_handler[i-1] != null) {");
      stream.println(ind(5) +       "getChild_handler[i-1].notifyDependencies();");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
    }
    // notify set
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) +   "else {");
      stream.println(ind(4) +     "if (getChild_handler[i] != null) {");
      stream.println(ind(5) +       "getChild_handler[i].notifyDependencies();");
      stream.println(ind(4) +     "} else getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      stream.println(ind(3) +   "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) +   "getChild_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(3) +   "handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) +   "ASTNode$DepGraphNode h = handler();");
      stream.println(ind(3) +   "if (h != null) h.notifyDependencies();");
    }
    // change in initial copy?
    stream.println(ind(3) +   "ASTNode initial  = inc_locateInitialCopy();");
    stream.println(ind(3) +   "if (initial != null) {");
    stream.println(ind(4) +     "state().enterConstruction();");
    stream.println(ind(4) +     "if (i >= initial.numChildren)");
    stream.println(ind(5) +       "initial.addChild(node);");
    stream.println(ind(4) +     "else initial.setChild(node, i);");
    stream.println(ind(4) +     "state().exitConstruction();");
    stream.println(ind(4) +     "return;");
    stream.println(ind(3) +   "}");
    stream.println(ind(2) + "}");
  }
  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 1
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) 
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i + 1];");
  }
  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, set child 2
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild3(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(2) + "if (init_children != null) {");
      stream.println(ind(3) +   "ASTNode d[] = new ASTNode[i << 1];");
      stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
      stream.println(ind(3) +   "init_children = d;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if (rewritten_children != null) {");
      stream.println(ind(3) +   "boolean[] b = new boolean[i << 1];");
      stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
      stream.println(ind(3) +   "rewritten_children = b;");
      stream.println(ind(2) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler != null) {");
      stream.println(ind(3) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[i << 1];");
      stream.println(ind(3) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
      stream.println(ind(3) +   "getChild_handler = h;");
      stream.println(ind(2) + "}");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 3
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild4(PrintWriter stream) {
    if (!ASTNode.fullFlush) {
      stream.println(ind(2) + "if (rewritten_children != null) {");
      stream.println(ind(3) +   "rewritten_children[i] = false;"); 
      stream.println(ind(2) + "}");   
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 3
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild5(PrintWriter stream) {
    stream.println(ind(2) + "if (children[i] != null) {");
    stream.println(ind(3) +   "children[i].inc_throwAway();");
    stream.println(ind(3) +   "children[i].parent = null;");
    stream.println(ind(2) + "}");
  }


  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 1
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i + 1];");
      stream.println(ind(3) + "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 2
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild2(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(2) + "if (init_children != null) {");
      stream.println(ind(3) +   "ASTNode d[] = new ASTNode[init_children.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(init_children, 0, d, 0, init_children.length);");
      stream.println(ind(3) +   "if (i < init_children.length) {");
      stream.println(ind(4) +     "System.arraycopy(init_children, i, d, i+1, init_children.length - i);");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "init_children = d;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if (rewritten_children != null) {");
      stream.println(ind(3) +   "boolean b[] = new boolean[rewritten_children.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(rewritten_children, 0, b, 0, rewritten_children.length);");
      stream.println(ind(3) +   "if (i < rewritten_children.length) {");
      stream.println(ind(4) +     "System.arraycopy(rewritten_children, i, b, i+1, rewritten_children.length - i);");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "rewritten_children = b;");
      stream.println(ind(2) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler != null) {");
      stream.println(ind(3) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[getChild_handler.length + 1];");
      stream.println(ind(3) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
//      stream.println(ind(3) +   "if (i < getChild_handler.length) {");
//      stream.println(ind(4) +     "System.arraycopy(getChild_handler, i, h, i+1, getChild_handler.length - 1);");
//      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "getChild_handler = h;");
//      stream.println(ind(3) +   "for (int k = i; k < getChild_handler.length; k++) {");
//      stream.println(ind(4) +     "if (getChild_handler[k] != null) {");
//      stream.println(ind(5) +       "getChild_handler[k].setParams(new Integer(k));");
//      stream.println(ind(4) +     "}");Region
//      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
    }
  }
  // ES_2011-10-06: Code generation for incremental evaluation, modifying tree, insert child 4
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild3(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "if (children == null || i > numChildren) {");
      stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
      stream.println(ind(3) + "} else {");
      stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
      if (ASTNode.incrementalLevelParam) { 
      stream.println(ind(4) +   "for (int k = i; k < children.length; k++) {");
      stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
      stream.println(ind(6) +       "getChild_handler[k].notifyDependencies();");
      stream.println(ind(5) +     "}");
      stream.println(ind(4) +   "}");
      }
      if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(4) +   "getChild_handler.notifyDependencies();");
      }
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler.flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler().flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    // locate initial copy
    stream.println(ind(3) +   "ASTNode initial = inc_locateInitialCopy();");
    stream.println(ind(3) +   "if (initial != null) {");
    stream.println(ind(4) +     "state().enterConstruction();");
    stream.println(ind(4) +     "initial.insertChild(node, i);");
    stream.println(ind(4) +     "state().exitConstruction();");
    stream.println(ind(4) +     "return;");
    stream.println(ind(3) +   "}");
    stream.println(ind(2) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, remove child 1
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {");
    }
    if (ASTNode.incrementalLevelRegion) {
    stream.println(ind(2) + "if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {");
    }
    // notify
    stream.println(ind(4) +   "if (children[i] != null)");
    stream.println(ind(5) +     "children[i].inc_notifyForRemove();");
    if (ASTNode.incrementalLevelParam) {
    stream.println(ind(4) +   "numChildren_handler.notifyDependencies();");
    stream.println(ind(4) +   "for (int k = i; k < children.length; k++) {");
    stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
    stream.println(ind(6) +       "getChild_handler[k].notifyDependencies();");
    stream.println(ind(5) +     "}");
    stream.println(ind(4) +   "}");
    }
    if (ASTNode.incrementalLevelAttr) {
    stream.println(ind(4) +   "getChild_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(4) +   "handler.flushRegion();");
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler.flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(4) + "handler().flushRegion();");
      stream.println(ind(3) + "for (int k = i; k < children.length; k++) {");
      stream.println(ind(4) +   "ASTNode child = children[i];");
      stream.println(ind(4) +   "if (child != null) {");
      stream.println(ind(5) +     "child.handler().flushRegion();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    // locate initial copy
    stream.println(ind(4) +   "ASTNode initial = inc_locateInitialCopy();");
    stream.println(ind(4) +   "if (initial != null) {");
    stream.println(ind(5) +     "state().enterConstruction();");
    stream.println(ind(5) +     "initial.removeChild(i);");
    stream.println(ind(5) +     "state().exitConstruction();");
    stream.println(ind(5) +     "return;");
    stream.println(ind(4) +   "}");
    stream.println(ind(3) + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, remove child 1
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild2(PrintWriter stream) {
    // rewrite code
    if (!ASTNode.fullFlush) {
      stream.println(ind(3) + "if (init_children != null) {");
      stream.println(ind(4) +   "if (i < init_children.length && init_children[i] != null) {");
      stream.println(ind(5) +     "init_children[i].inc_throwAway();");
      stream.println(ind(4) +   "}");
      stream.println(ind(4) +   "System.arraycopy(init_children, i+1, init_children, i, init_children.length-i-1);");
      stream.println(ind(4) +   "init_children[init_children.length-1] = null;");
      stream.println(ind(3) + "}");      
      stream.println(ind(3) + "if (rewritten_children != null) {");
      stream.println(ind(4) +   "System.arraycopy(rewritten_children, i+1, rewritten_children, i, rewritten_children.length-i-1);");
      stream.println(ind(4) +   "rewritten_children[rewritten_children.length-1] = false;");
      stream.println(ind(3) + "}");
    }
    //
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (getChild_handler != null) {");
      stream.println(ind(4) +   "getChild_handler[numChildren] = null;");
//      stream.println(ind(4) +   "System.arraycopy(getChild_handler, i+1, " + 
//          "getChild_handler, i, getChild_handler.length-i-1);");
//      stream.println(ind(4) +   "for (int k = i; k < getChild_handler.length; k++) {");
//      stream.println(ind(5) +     "if (getChild_handler[k] != null) {");
//      stream.println(ind(6) +       "getChild_handler[k].setParams(new Integer(k));");
//      stream.println(ind(5) +     "}");
//      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
  }
  // ES_2011-11-28: Code generation for incremental evaluation, modifying tree, remove child 3
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild3(PrintWriter stream) {
    // prevent recursive call during state handling where setParent calls removeChild
    stream.println(ind(4) + "child.inc_throwAway();");      
  }


  public void ASTDecl.jjtGenFlushCache(PrintWriter stream) {

    // ES_2011-10-10: Checking full flush flag
    if (ASTNode.fullFlush) {

      if (name().equals("ASTNode")) {
        // ES_TODO: These should be protected, public now for debugging reasons
        stream.println(ind + "public ASTNode[] init_children;");
        stream.println(ind + "public boolean[] rewritten_children;");
        stream.println(ind + "protected boolean inc_hasEnclosingRewrittenNode() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
        stream.println(ind(3) +   "if (parent.rewritten_children != null && parent.rewritten_children[index]) {");
        stream.println(ind(4) +     "return true;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.getParent();");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}");
      }
    }
    //if (name().equals("List")) {
    //  stream.println(ind + "public boolean is$Final() { return super.is$Final() && !list$touched; }");
    //}

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.print(ind + "public void flushCache() {\n");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);

    if (ASTNode.fullFlush) {
      if(!name().equals("ASTNode"))
        stream.print(ind(2) + "super.flushCache();\n");
      else {
        // flush rewrite or traverse to child
        stream.println(ind(3) + "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(4) +   "if (rewritten_children != null && rewritten_children[i]) {");
        stream.println(ind(5) +     "if (init_children[i] != null) {");
        stream.println(ind(6) +       "children[i] = init_children[i];");
        stream.println(ind(6) +       "init_children[i] = null;");
        stream.println(ind(5) +     "}");
        stream.println(ind(5) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +   "} else {");
        stream.println(ind(5) +     "getChildNoTransform(i).flushCache();");
        stream.println(ind(4) +   "}");
        stream.println(ind(3) + "}");
      }
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrEq equ = getSynEq(k);
        AttrDecl attr = equ.decl();
        String u = attr.resetVisit() + attr.resetCache();
        u = u.replaceAll("#NAME#", attr.attributeSignature());
        stream.print(u);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        String u = attr.resetVisit() + attr.resetCache();
        u = u.replaceAll("#NAME#", attr.attributeSignature());
        stream.print(u);
      }
  
      stream.print(flushCollectionCacheString());
    }

    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.print(ind + "}\n");

    if (ASTNode.fullFlush) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.print(ind + "public void flushCollectionCache() {\n");
      if(!name().equals("ASTNode"))
        stream.print(ind(2) + "super.flushCollectionCache();\n");
      stream.print(flushCollectionCacheString());
      stream.print(ind + "}\n");
    }
  }


  public void ASTDecl.jjtGenCloneNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    if(j2me) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.print(ind + "public void init$copy(Object o) {\n");
      stream.print(ind(2) + name() + " node = (" + name() + ")o;\n");
      for(Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
        ClassBodyObject o = (ClassBodyObject)iter.next();
        jrag.AST.SimpleNode n = o.node;
        if(n instanceof jrag.AST.ASTAspectFieldDeclaration) {
          jrag.AST.Token t2 = ((jrag.AST.SimpleNode)n.jjtGetChild(1)).firstToken;
          String name = t2.image;
          StringBuffer buf = new StringBuffer();
          n.unparseClassBodyDeclaration(buf, name(), aspectJ);
          String field = buf.toString();
          if(field.indexOf("static") == -1 && field.indexOf("final") == -1)
            stream.print(ind(2) + "node." + name + " = " + name + ";\n");
        }
      }

      if(name().equals("ASTNode")) {
        stream.print(ind(2) + "if(children != null) {\n");
        stream.print(ind(3) + "node.children = new ASTNode[children.length];\n");
        stream.print(ind(3) + "for(int i = 0; i < children.length; i++)\n");
        stream.print(ind(4) + "node.children[i] = children[i];\n");
        stream.print(ind(2) + "}\n");
      }
      else {
        stream.print(ind(2) + "super.init$copy(o);\n");
      }

    }
    else if(ASTNode.java5) {
      // covariant return type when using Java 5
      String name = name();
      if(name().equals("Opt") || name().equals("List") || name().equals("ASTNode"))
        name = name + "<T>";
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ASTNode.suppressWarnings() + ind + "public " + name + " clone() throws CloneNotSupportedException {");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ASTNode.suppressWarnings() + ind + "public Object clone() throws CloneNotSupportedException {");
    }
    if(ASTNode.block) stream.print(ASTNode.blockBegin);

    if(!j2me)
      stream.print(ind(2) + name() + " node = (" + name() + ")super.clone();\n");

    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq equ = getSynEq(k);
      AttrDecl attr = equ.decl();
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }

    if(ASTNode.rewriteEnabled) {
      stream.print(ind(2) + "node.in$Circle(false);\n");
      if(ASTNode.stagedRewrites)
        stream.print(ind(2) + "node.is$Final(0);\n");
      else
        stream.print(ind(2) + "node.is$Final(false);\n");
    }

    // I'd like to set the parent to null, but this would change the interface of fullCopy,
    // and existing applications might depend on the copy to still be parented by the original
    // AST. So I don't do it. Yet. 20100416/GH.
    // stream.print(ind(2) + "node.parent = null;\n");

    if(!j2me)
      stream.print(ind(2) + "return node;\n");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.print(ind + "}\n");

    if(!hasAbstract()) {
      String copyBody;
      if(j2me) {
        copyBody =
          ind(3) + "#CLASS# node = new #CLASS#();\n" +
          ind(3) + "this.init$copy(node);\n" +
          ind(3) + "return node;\n";
      }
      else {
        copyBody =
          ind(3) + "try {\n" +
          ind(4) + "#CLASS# node = (#CLASS#)clone();\n" +
          ind(4) + "node.parent = null;\n" +
          ind(4) + "if(children != null) node.children = (ASTNode[])children.clone();\n" +
          // ES_2011-10-07: Code generation for incremental evaluation, copy
           (ASTNode.incremental ? genIncrementalCopyNode() : "") +
          ind(4) + "return node;\n" +
          ind(3) + "} catch (CloneNotSupportedException e) {\n" +
          ind(3) + "}\n" +
          ind(3) + "System.err.println(\"Error: Could not clone node of type \" + getClass().getName() + \"!\");\n" +
          ind(3) + "return null;\n";
      }

      String s =
        ind + "/**\n" +
        ind + " * @apilevel internal\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #RETURN# copy() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        copyBody +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #RETURN# fullCopy() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "#ID# res = (#ID#)copy();\n" +
        ind(2) + "for(int i = 0; i < getNumChildNoTransform(); i++) {\n" + 
        ind(3) + "ASTNode node = getChildNoTransform(i);\n" +
        ind(3) + "if(node != null) node = node.fullCopy();\n" +
        // ES_2011-10-04: Code generation for incremental evaluation, clone
        (ASTNode.incremental ? 
          jjtGenIncrementalCloneNode() : 
          ind(3) + "res.setChild(node, i);\n") +
        // OLD: ind(3) + "res.setChild(node, i);\n"
        //
        ind(2) + "}\n" +
        ind(2) + "return res;\n    }\n" +
        (ASTNode.block ? ASTNode.blockEnd : "");

      String returnName = name();
      if(name().equals("Opt") || name().equals("List") || name().equals("ASTNode"))
        returnName = returnName + "<T>";
      s = s.replaceAll("#RETURN#", ASTNode.java5 ? returnName : "ASTNode");
      s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
      s = s.replaceAll("#CLASS#", name());
      s = s.replaceAll("#ID#", name());
      stream.print(s);
    }
  }

  // ES_2011-10-07: Code generation for incremental evaluation, copy
  // Making sure that handlers are cloned correctly, pointing to the right node
  public String ASTDecl.genIncrementalCopyNode() {
    StringBuffer buf = new StringBuffer();
    buf.append(ind(4) + "node.inc_state = inc_CLONED;\n");
    buf.append(ind(4) + "for (int i = 0; node.children != null && i < node.children.length; i++) {\n");
    buf.append(ind(5) +   "node.children[i] = null;\n");
    buf.append(ind(4) + "}\n");
    buf.append(ind(4) + "inc_copyHandlers(node);\n");
    return buf.toString();
  }


  // ES_2011-10-04: Changing this to an internal set of child via the children array to not send notifications
  public String ASTDecl.jjtGenIncrementalCloneNode() {
    StringBuffer buf = new StringBuffer();
    //buf.append(ind(3) + "res.children[i] = node;\n" + ind(3) + "node.parent = res;\n");
    buf.append(ind(3) + "state().enterConstruction(); res.setChild(node, i); state().exitConstruction();\n");
    return buf.toString();
  }

  public void ASTDecl.jjtGenCheckTreeStructure(PrintWriter stream) {
    stream.println(ind + "public void " + name() + ".jjtAddChild(Node n, int i) {");
    stream.println(ind(2) + "checkChild(n, i);");
    if(name().equals("ASTNode")) {
      stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    }
    stream.println(ind(2) + "super.jjtAddChild(n, i);");
    stream.println("}\n");
    if(name().equals("Opt")) {
      stream.println(ind + "public void Opt.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(i > 0) throw new Error(\"Optional nodes can only have one child\");");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"Node type must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else if(name().equals("List")) {
      stream.println(ind + "public void List.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"The node type of child \" + i + \" must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else {
      int j = 0;
      stream.println(ind + "public void " + name() + ".checkChild(Node n, int i) {");
      for(Iterator iter = getComponents(); iter.hasNext(); ) {
        Components c = (Components)iter.next();
        c.jjtGenCheckTreeStructure(stream, j);
        if(!(c instanceof TokenComponent)) {
          j++;
        }
      }
      stream.println(ind + "}\n");
    }
  }
  public void Components.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
  }
  public void ListComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + ") {");
    stream.println(
        ind(3) + "if(!(n instanceof List))\n" + 
        ind(4) + "throw new Error(\"Child number " + j + " of " + hostClass().name() + 
        " has the type \" + n.getClass().getName() + \" which is not an instance of List\");");
    stream.println(ind(3) + "for(int k = 0; k < ((List)n).getNumChildNoTransform(); k++)");
    stream.println(
        ind(3) + "if(!(((List)n).getChildNoTransform(k) instanceof " + type() + "))\n" + 
        ind(4) + "throw new Error(\"Child number \" + k + \" in " + name() + "List" + 
        " has the type \" + ((List)n).getChildNoTransform(k).getClass().getName() + \" which is not an instance of " +
        type() + "\");");
    stream.println(ind(2) + "}");
  }
  public void OptionalComponent.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + ") {");
    stream.println(
        ind(3) + "if(!(n instanceof Opt))\n" + 
        ind(4) + "throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of Opt\");");
    stream.println(
        ind(3) + "if(((Opt)n).getNumChildNoTransform() != 0 && !(((Opt)n).getChildNoTransform(0) instanceof " + type() + "))\n" +
        ind(4) + "throw new Error(\"Optional " + name() + 
        " has the type \" + ((Opt)n).getChildNoTransform(0).getClass().getName() + \" which is not an instaRegionnce of " +
        type() + "\");");
    stream.println(ind(2) + "}");
  }
  public void AggregateComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + " && !(n instanceof " + type() + ")) " + 
        " throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of " + type() + "\");");
  }

  public void ASTDecl.jjtGenDumpTree(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    StringBuffer sb = new StringBuffer();
    sb.append(ind + "public void " + name() + ".dumpTree(String indent, java.io.PrintStream pStream) {\n" + 
        ind(2) + "pStream.println(indent + \"" + name() + "\"");
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof TokenComponent) {
        TokenComponent t = (TokenComponent)c;
        String id = t.getTokenId().getID();
        sb.append("+ \"\\\"\" + get" + id + "() + \"\\\"\"");
      }
    }
    sb.append(");\n        String childIndent = indent + \"  \";\n" + 
        ind(2) + "for(int i = 0; i < getNumChild(); i++)\n" + 
        ind(3) + "getChild(i).dumpTree(childIndent, pStream);\n" +
        ind + "}\n");
    stream.println(sb.toString());
  }

  public void ASTDecl.jjtGenVisitor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println(ind + "public Object " + name() + ".jjtAccept(" + parserName + "Visitor visitor, Object data) {\n" +
        ind(2) + "return visitor.visit(this, data);\n" + 
        ind + "}\n");
  }

  public void ASTDecl.jjtGenConstructor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String finalInit = "";
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        finalInit = ind(2) + "is$Final(state().rewritePhase);\n";
      else
        finalInit = ind(2) + "is$Final(true);\n";
    }
    String s;
    if(jjtree) {
      s = ind + "public #ID#.#ID#(int i) {\n" +
        ind(2) + "super(i);\n" + finalInit +
        ind + "}\n" +
        ind + "public #ID#.#ID#(" + parserName + " p, int i) {\n" +
        ind(2) + "this(i);\n" +
        ind(2) + "parser = p;\n" + finalInit +
        ind + "}\n" +
        ind + "public #ID#.#ID#() {\n" + 
        ind(2) + "this(0);\n" + 
        "#NTA#";
    }
    else {
      s = ind + "public #ID#.#ID#() {\n" + // Lgg till null fr agg, tom lista fr list, false fr opt
        ind(2) + "super();\n" + 
        "#NTA#";
    }
    String t = new String();
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponentsNTA) {
        //t = t + ind(2) + "setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof OptionalComponentNTA) {
        //t = t + ind(2) + "setChild(new Opt(), " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof AggregateComponentsNTA) {
        //t = t + ind(2) + "setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
    }
    s = s.replaceAll("#ID#", name());
    s = s.replaceAll("#NTA#", t);
    stream.println(s);
    // Initialize node
    i = 0;
    // ES_2011-11-23: Code generation for incremental evaluation  
    if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorStartConstruction());
    //
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponents) {
        stream.println(ind(2) + "setChild(new List(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof OptionalComponent) {
        stream.println(ind(2) + "setChild(new Opt(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof AggregateComponents) {
        //stream.println(ind(2) + "setChild(null, " + String.valueOf(i) + ");");
        i++;
      }
    }
    // ES_2011-11-23: Code generation for incremental evaluation  
    if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorEndConstruction());
    //
    stream.println(finalInit);
    stream.println(ind + "}\n");

    if(numNonNTAComponents() != 0) {
      stream.print(buildingConstructor());
      if(ASTNode.beaver)
        stream.print(buildingSymbolConstructor());
    }

    if(name().equals("Opt")) {
      if(ASTNode.java5)
        stream.println(ind + "public Opt.Opt(T opt) {");
      else
        stream.println(ind + "public Opt.Opt(ASTNode opt) {");
      // ES_2011-11-23: Code generation for incremental evaluation  
      if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorStartConstruction());
      //
      stream.println(ind(2) + "setChild(opt, 0);");
      // ES_2011-11-23: Code generation for incremental evaluation  
      if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorEndConstruction());
      //
      stream.println(ind + "}\n");
    }

  }

  public void ASTDecl.jjtGen(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String s;

    jjtGenConstructor(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenCloneNode(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenFlushCache(stream);
    if(jjtree) {
      jjtGenDumpTree(stream, parserName, jjtree, rewriteEnabled);
      jjtGenVisitor(stream, parserName, jjtree, rewriteEnabled);
      try {
        jjtGenCheckTreeStructure(stream);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }

    // Generate code common for all nodes by adding them to ASTNode
    if(name().equals("ASTNode")) {
      jjtGenASTNode(stream, parserName, jjtree, rewriteEnabled);
      env().genRewriteOrderChecks(stream);
      env().genReset(stream);
      if(ASTNode.java5) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public java.util.Iterator<T> ASTNode.iterator() {");
        if(ASTNode.block) stream.append(ASTNode.blockBegin);
        stream.println(ind + "return new java.util.Iterator<T>() {");
        stream.println(ind(3) + "private int counter = 0;");
        stream.println(ind(3) + "public boolean hasNext() {");
        stream.println(ind(4) + "return counter < getNumChild();");
        stream.println(ind(3) + "}");
        stream.println(ind(3) + "@SuppressWarnings(\"unchecked\") public T next() {");
        stream.println(ind(4) + "if(hasNext())");
        stream.println(ind(5) + "return (T)getChild(counter++);");
        stream.println(ind(4) + "else");
        stream.println(ind(5) + "return null;");
        stream.println(ind(3) + "}");
        stream.println(ind(3) + "public void remove() {");
        stream.println(ind(4) + "throw new UnsupportedOperationException();");
        stream.println(ind(3) + "}");
        stream.println(ind + "};");
        if(ASTNode.block) stream.append(ASTNode.blockEnd);
        stream.println(ind + "}");
      }
      
    }
    else if(name().equals("List")) {
      if(ASTNode.java5)
        stream.println(ind + "public List<T> List.add(T node) {");
      else
        stream.println(ind + "public List List.add(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      if(debugMode) {
        stream.println(ind(2) + "if(node instanceof List)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type List\");");
        stream.println(ind(2) + "if(node instanceof Opt)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type Opt\");");
      }
      stream.println(ind(2) + "addChild(node);");
      stream.println(ind(2) + "return this;");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}\n");
      stream.println(ind + "public void List.insertChild(ASTNode node, int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
      //
      stream.println(ind(2) + "list$touched = true;");
      stream.println(ind(2) + "super.insertChild(node, i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      if(ASTNode.java5)
        stream.println(ind + "public void List.addChild(T node) {");
      else
        stream.println(ind + "public void List.addChild(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
      //
      stream.println(ind(2) + "list$touched = true;");
      stream.println(ind(2) + "super.addChild(node);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void List.removeChild(int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
        stream.println(ind(2) + "list$touched = true;");
      //
      stream.println(ind(2) + "super.removeChild(i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "public int List.getNumChild() {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) {
        stream.println(ind(2) + "if(list$touched) {");
        stream.println(ind(3) + "for(int i = 0; i < getNumChildNoTransform(); i++)");
        stream.println(ind(4) + "getChild(i);");
        stream.println(ind(4) + "list$touched = false;");
        stream.println(ind(3) + "}");
      } 
      //
      stream.println(ind(3) + "return getNumChildNoTransform();");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
        stream.println(ind + "private boolean List.list$touched = true;");
    }
    else if(name().equals("Opt")) {
      // do not override getNumChild with implementation below
    }
    else {

      if(jjtree) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public int " + name() + ".getNumChild() {");
        // ES_2011-09-20: Code generation for incremental evaluation, tracking numChild
        if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
        // 
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "protected int " +name() + ".numChildren() {");
        // ES_2011-09-20: Code generation for incremental evaluation, tracking numChild
        if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
        // 
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      if(debugMode && isRootNode()) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "protected boolean " + name() + ".debugNodeAttachmentIsRoot() { return true; }");
      }
    }
    if(rewriteEnabled) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean " + name() + ".mayHaveRewrite() {");
      if(name().equals("List")) {
        // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
        if (!(ASTNode.incremental || ASTNode.fullFlush)) {
          // old code 
          stream.println(ind(2) + "return true;");
        } else {
          stream.println(ind(2) + "return false;");
        }
      } else if(!hasRewrites())
        stream.println(ind(2) + "return false;");
      else if(!stagedRewrites || rewriteWithNoPhaseCondition())
        stream.println(ind(2) + "return true;");
      else {
        for(Iterator iter = rewritePhaseConditions().iterator(); iter.hasNext(); ) {
          String condition = (String)iter.next();
          stream.println(ind(2) + "if(" + condition + ") return true;");
        }
        stream.println(ind(2) + "return false;");
      }
      stream.println(ind + "}");
    }

    // ES_2011-09-19: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncremental(stream);
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  public void ASTDecl.jjtGenIncremental(PrintWriter stream) {
    jjtGenIncrementalHandlers(stream);
    jjtGenIncrementalCopyHandlers(stream);
    jjtGenIncrementalTreeModification(stream);
    jjtGenIncrementalNTAChildCheck(stream);
    jjtGenIncrementalReactToChange(stream);
    jjtGenIncrementalReactToASTChange(stream);
    jjtGenIncrementalState(stream);
    jjtGenIncrementalRegions(stream);
    if (ASTNode.incrementalDebug) jjtGenIncrementalDebug(stream);
  }

  // ES_2011-10-06: Code generation for incremental evaluation, tree modification
  public void ASTDecl.jjtGenIncrementalTreeModification(PrintWriter stream) {

    if (name().equals("ASTNode")) {

      // rewrite code: intial copy store -- full flush also adds this
      if (!ASTNode.fullFlush) {

        // ES_TODO: These should be protected, public now for debugging reasons
        stream.println(ind + "public ASTNode[] ASTNode.init_children;");
        stream.println(ind + "public boolean[] ASTNode.rewritten_children;");

        // method: inc_hasEnclosingRewrittenNode
        stream.println(ind + "protected boolean ASTNode.inc_hasEnclosingRewrittenNode() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        //stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
        stream.println(ind(3) +   "if (parent.mayHaveRewrite()) {");
        //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
        //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
        stream.println(ind(4) +     "return true;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.getParent();");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); // end method: inc_hasEnclosingRewrittenNode

        // method: inc_locateEnclosingRewrittenNode
        stream.println(ind + "protected ASTNode ASTNode.inc_locateEnclosingRewrittenNode() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        //stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
        stream.println(ind(3) +   "if (parent.mayHaveRewrite()) {");
        //  stream.println(ind(3) +   "if (parent.rewritten_children != null && index >= 0 && " + 
        //  "index < parent.rewritten_children.length && parent.rewritten_children[index]) {");
        stream.println(ind(4) +     "return parent;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.getParent();");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return null;");
        stream.println(ind + "}"); // end method: inc_locateEnclosingRewrittenNode

        // method: inc_resetRewrites
        stream.println(ind + "protected void ASTNode.inc_resetRewrites() {");
        stream.println(ind(2) + "for (int i = 0; i < numChildren; i++) {");
        stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length) {");
        stream.println(ind(4) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +     "if (init_children[i] != null) {");
        stream.println(ind(5) +       "init_children[i].inc_throwAway();");
        stream.println(ind(5) +       "init_children[i] = null;");
        stream.println(ind(4) +     "}");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "if (children[i] != null) {");
        stream.println(ind(4) +     "children[i].inc_resetRewrites();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind + "}"); // end method: inc_resetRewrites
      }

      // method: inc_restoreEnclosingRewrite    
      stream.println(ind + "protected void ASTNode.inc_restoreEnclosingRewrite() {");
      stream.println(ind(2) + "ASTNode child = this;");
      stream.println(ind(2) + "ASTNode parent = this.parent;");
      stream.println(ind(2) + "while (parent != null) {");
//      stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
      stream.println(ind(3) +   "int index = -1;");
      stream.println(ind(3) +   "for (int i = 0; i < parent.children.length; i++) {");
      stream.println(ind(4) +     "if (parent.children[i] == child) {");
      stream.println(ind(5) +       "index = i;");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
//      stream.println(ind(3) +   "if (parent.mayHaveRewrite() && parent.inc_restoreInitialForIndex(index)) {");
      stream.println(ind(3) +   "if (child.mayHaveRewrite() && parent.inc_restoreInitialForIndex(index)) {");
      stream.println(ind(4) +     "break;");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "child = parent;");
      stream.println(ind(3) +   "parent = parent.getParent();");
      stream.println(ind(2) + "}");
      stream.println(ind + "}"); // end method: inc_restoreEnclosingRewrite
    
      // method: inc_restoreInitialForIndex
      stream.println(ind + "protected boolean ASTNode.inc_restoreInitialForIndex(int index) {");
      stream.println(ind(2) + "if (init_children != null && index < init_children.length " + 
                                                  "&& init_children[index] != null) {");
      stream.println(ind(3) +   "setChild(init_children[index], index);");
      stream.println(ind(3) +   "init_children[index] = null;");
      stream.println(ind(3) +   "return true;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return false;");
      stream.println(ind + "}"); // end method: inc_restoreInitialForIndex

      // method: inc_locateInitialCopy
      stream.println(ind + "protected ASTNode ASTNode.inc_locateInitialCopy() {");
      // locate enclosing rewrite
      stream.println(ind(2) + "ASTNode child = this;");
      stream.println(ind(2) + "ASTNode parent = getParent();");
      stream.println(ind(2) + "LinkedList indexList = new LinkedList();");
      stream.println(ind(2) + "while (parent != null) {");
      stream.println(ind(3) +   "int index = child.childIndex;");
      stream.println(ind(3) +   "indexList.addFirst(new Integer(index));");
      stream.println(ind(3) +   "if (parent.init_children != null && index >= 0 && " +
                                "index < parent.init_children.length && parent.init_children[index] != null) {");
      // stream.println(ind(3) +   "if (parent.is$Final() != child.is$Final()) {");
      stream.println(ind(4) +     "break;");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "child = parent;");
      stream.println(ind(3) +   "parent = child.getParent();");
      stream.println(ind(2) + "}");
      // root reached -- no enclosing rewrite
      stream.println(ind(2) + "if (parent == null) {");
      stream.println(ind(3) +   "return null;");
      stream.println(ind(2) + "}");
      // root not reached -- enclosing rewrite found
      stream.println(ind(2) + "boolean first = true;");
      stream.println(ind(2) + "for (Iterator itr = indexList.iterator(); itr.hasNext();) {");
      stream.println(ind(3) +   "int index = ((Integer)itr.next()).intValue();");
      stream.println(ind(3) +   "if (first) {");
      stream.println(ind(4) +     "first = false;");
      stream.println(ind(4) +     "child = parent.init_children[index];");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else if (index < parent.getNumChildNoTransform()) {");
      stream.println(ind(4) +     "child = parent.getChildNoTransform(index);");
      stream.println(ind(4) +     "parent = child;");
      stream.println(ind(3) +   "} else return null;");
      // stream.println(ind(3) +   "child = parent.getChildNoTransform(index);");
      // stream.println(ind(3) +   "parent = child;");
      // stream.println(ind(3) +   "if (child == null) {");
      // stream.println(ind(4) +     "throw new RuntimeException(\"Incremental tree modification error: " + 
      //                                        "premature end of change point path\");");
      // stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
      // initial change point found
      stream.println(ind(2) + "return child;");      
      stream.println(ind + "}"); // end method: inc_locateInitialCopy
      
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, initialization of handlers
  public void ASTDecl.jjtGenIncrementalHandlers(PrintWriter stream) {


    // if a change has been made to a list then the list should again be touched by the "touch rewrite"
    // but this does not happen if the list is final.
    //if (name().equals("List") && !ASTNode.fullFlush) {
    //  stream.println(ind + "public boolean List.is$Final() { return super.is$Final() && !list$touched; }");
    //}
    //

    // level region: one handler per region, non-region root nodes need a method to find the handler of their region
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() && !hasRegionRootAsSuperClass()) {
        stream.println(ind + "protected ASTNode$DepGraphNode " + name() + 
          ".handler = new ASTNode$DepGraphNode(this);");                    
      }
    }

    // level node: one handler per node
    if (ASTNode.incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "protected ASTNode$DepGraphNode " + 
          "ASTNode.handler = new ASTNode$DepGraphNode(this);");                    
      }
    } 

    // level param, attr: at least one handler per attribute
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      // handlers specific for ASTNode
      if (name().equals("ASTNode")) {
        if (ASTNode.incrementalLevelParam) {
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getParent_handler = " + 
              "new ASTNode$DepGraphNode(this, \"getParent\", null);");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.numChildren_handler = " +
              "new ASTNode$DepGraphNode(this, \"numChildren\", null);");
          stream.println(ind + "protected ASTNode$DepGraphNode[] ASTNode.getChild_handler;");
        } 
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getParent_handler = " + 
              "new ASTNode$DepGraphNode(this, \"getParent\");");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.numChildren_handler = " +
              "new ASTNode$DepGraphNode(this, \"numChildren\");");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getChild_handler = " +
              "new ASTNode$DepGraphNode(this, \"getChild\");");
        }
      }
      // collect attributes
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynDecl(); k++) {
 	      AttrDecl attr = getSynDecl(k);
      	if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
    	for(int k = 0; k < getNumInhDecl(); k++) {
    	  AttrDecl attr = getInhDecl(k);
    	  if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for (int k = 0; k < getNumCollDecl(); k++) {
    	  CollDecl attr = getCollDecl(k);
        list.add(attr);      
      }
      // attribute code 
      for (Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (ASTNode.incrementalLevelParam) {
          // level param: check if this is a parameterized attribute
    	    if (attr.getNumParameter() > 0) {
    	      stream.println(ind + "protected java.util.Map " + name() + "." + attr.attributeSignature() + 
                  "_handler = new java.util.HashMap(4);");
    	    } else {
            stream.println("  protected ASTNode$DepGraphNode " + name() + "." + 
                  attr.attributeSignature() + "_handler;");
          }
        }
        // level attr: Add one handler per attribute
        if (ASTNode.incrementalLevelAttr) {
  		      stream.println(ind + "protected ASTNode$DepGraphNode " + name() + "." + 
                  attr.attributeSignature() + "_handler;");            
        }
      }
    }

  }



  // ES_2011-11-22: Code generation for incremental evaluation, copying of handlers
  public void ASTDecl.jjtGenIncrementalCopyHandlers(PrintWriter stream) {

    stream.println(ind + "protected void " + name() + ".inc_copyHandlers(" + name() + " copy) {");
    // ast handlers
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "if (getChild_handler != null)");
        stream.println(ind(3) +   "copy.getChild_handler = (ASTNode$DepGraphNode[])getChild_handler.clone();");
        stream.println(ind(2) + "copy.numChildren_handler = new ASTNode$DepGraphNode(numChildren_handler, copy);");
        stream.println(ind(2) + "copy.getParent_handler = new ASTNode$DepGraphNode(getParent_handler, copy);");
        stream.println(ind(2) + "for (int i = 0; getChild_handler != null && i < getChild_handler.length; i++) {");
        stream.println(ind(3) +   "if (getChild_handler[i] != null) {");
        stream.println(ind(4) +     "copy.getChild_handler[i] = new ASTNode$DepGraphNode(getChild_handler[i], copy);");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "copy.getChild_handler = new ASTNode$DepGraphNode(getChild_handler, copy);");
        stream.println(ind(2) + "copy.numChildren_handler = new ASTNode$DepGraphNode(numChildren_handler, copy);");
        stream.println(ind(2) + "copy.getParent_handler = new ASTNode$DepGraphNode(getParent_handler, copy);");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);");
      }
      if (ASTNode.incrementalLevelRegion) {
        if (isRegionRoot())
          stream.println(ind(2) + "copy.handler = new ASTNode$DepGraphNode(handler, copy);");
      }
    } else {
      stream.println(ind(2) + "super.inc_copyHandlers(copy);");
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      // tokens
      for (int c = 0; c < getNumComponents(); c++) {
 	      Components comp = getComponents(c);
 	      if (comp instanceof TokenComponent) {
          stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
          stream.println(ind(3) +   "copy.get" + ((TokenComponent)comp).getTokenId().getID() + 
                                    "_handler = new ASTNode$DepGraphNode(get" + 
                               ((TokenComponent)comp).getTokenId().getID() + "_handler, copy);\n");
          stream.println(ind(2) + "}");

 	    	}
 	    }
      // Collect attributes: syn then inh
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynDecl(); k++) {
        AttrDecl attr = getSynDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      // Attribute code: propagate change of all cached values being removed
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (attr.getNumParameter() > 0) {
          if (ASTNode.incrementalLevelParam) {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   "copy." + attr.attributeSignature() + "_handler = new java.util.HashMap(4);");
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) + "copy." + attr.attributeSignature() + "_handler = new ASTNode$DepGraphNode(" + 
                                    attr.attributeSignature() + "_handler, copy);");
            stream.println(ind(2) + "}");
          }
        } else {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) + "copy." + attr.attributeSignature() + "_handler = new ASTNode$DepGraphNode(" + 
                                  attr.attributeSignature() + "_handler, copy);");
          stream.println(ind(2) + "}");
        }
  	  }    
    }

    // end of method
    stream.println(ind + "}");
  }

  // ES_2011-09-23: Code generation for incremental evaluation, check if NTA child
  public void ASTDecl.jjtGenIncrementalNTAChildCheck(PrintWriter stream) {
    // collect attributes
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynDecl(); k++) {
      AttrDecl attr = getSynDecl(k);
    	if (attr.isNTA()) 
        list.add(attr);
    }
  	for(int k = 0; k < getNumInhDecl(); k++) {
  	  AttrDecl attr = getInhDecl(k);
  	  if (attr.isNTA()) 
        list.add(attr);
    }
    // method signature
    stream.println(ind + "protected boolean " + name() + ".childIsNTA(int index) {");
    // attribute code
    boolean first = true;
    for (Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      if (first) {
        stream.print(ind(2) + "if (");
        first = false;
      } else stream.print(" || ");
      stream.print("index == " +  attr.indexNTAchild());
    }
    if (!first) {
      stream.println(")");
      stream.println(ind(3) + "return true;");
    }
    // method end
    if (name().equals("ASTNode"))
      stream.println(ind(2) + "return false;");
    else stream.println(ind(2) + "return super.childIsNTA(index);");
    stream.println(ind + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, react to change
  public void ASTDecl.jjtGenIncrementalReactToChange(PrintWriter stream) {

    // method: reactToDependencyChange
    if (ASTNode.incrementalLevelParam)
      stream.println(ind + "public void " + name() + ".reactToDependencyChange(String attrID, Object _parameters) {");      
    if (ASTNode.incrementalLevelAttr) 
      stream.println(ind + "public void " + name() + ".reactToDependencyChange(String attrID) {");      
    if (ASTNode.incrementalLevelNode) 
      stream.println(ind + "public void " + name() + ".reactToDependencyChange() {");      
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() || name().equals("ASTNode")) 
        stream.println(ind + "public void " + name() + ".reactToDependencyChange() {");      
    }

    if (ASTNode.incrementalChangeFlush) {
      if (ASTNode.incrementalLevelRegion) {
        if (isRegionRoot())
        jjtGenIncrementalChangeFlush(stream);
      } else {
        jjtGenIncrementalChangeFlush(stream);
      }
    }

    // super class if not ASTNode
    if (!name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam)
        stream.println(ind(2) + "super.reactToDependencyChange(attrID, _parameters);");      
      if (ASTNode.incrementalLevelAttr) 
        stream.println(ind(2) + "super.reactToDependencyChange(attrID);");   
    }
    if (ASTNode.incrementalLevelNode) 
        stream.println(ind(2) + "handler.notifyDependencies();");      
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) 
        stream.println(ind(2) + "handler.notifyDependencies();");      
    }

    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() || name().equals("ASTNode")) 
        stream.println(ind + "}");      
    } else {
      stream.println(ind + "}");
    }
    // end method: reactToDependencyChange


    // method: inc_flush
    if (ASTNode.incrementalChangeFlush) {

      // collect attributes: syn, inh
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr != null && (attr.getLazy() || attr.isCircular())) 
          list.add(attr);
      }


      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
        stream.println(ind + "public void " + name() + ".inc_flush() {");

        if (ASTNode.incrementalLevelNode) {
          // check of this is an NTA at the parent
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "parent.inc_flush_NTA(this);");
          stream.println(ind(2) + "}");
          // check if this is a rewritten child of the parent, 
          // need to recheck parent in case this was a NTA an it was removed
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "parent.inc_flush_child(this);");
          stream.println(ind(2) + "}");
        }

        // flush attributes
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          // NTAs
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          } 
          // Non NTAs
          else {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_values != null && !" + 
                attr.attributeSignature() + "_values.isEmpty()) {");
              String u = attr.resetVisit() + attr.resetCache();
              u = u.replaceAll("#NAME#", attr.attributeSignature());
              stream.print(u);              
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed) {");
              String u = attr.resetVisit() + attr.resetCache();
              u = u.replaceAll("#NAME#", attr.attributeSignature());
              stream.print(u);              
              stream.println(ind(2) + "}");
            }
          }
        }
        if (name().equals("ASTNode")) {
        } else {
          stream.println(ind(2) + "super.inc_flush();");
        }
        stream.println(ind + "}");        
      }
      // end method: inc_flush

      // methods: inc_flush_child
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
        if (name().equals("ASTNode")) {
        stream.println(ind + "public boolean ASTNode.inc_flush_child(ASTNode node) {");
        stream.println(ind(2) + "for (int i = 0; i < children.length; i++) {");        
        stream.println(ind(3) +   "if (children[i] == node && rewritten_children != null && " +
                                      "i < rewritten_children.length && rewritten_children[i]) {");
        stream.println(ind(4) +     "node.inc_restoreEnclosingRewrite();");
        stream.println(ind(4) +     "return true;");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
        }
      }
      // end methods: inc_flush_NTA

      // methods: inc_flush_NTA
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
        stream.println(ind + "public boolean " + name() + ".inc_flush_NTA(ASTNode node) {");
        if (name().equals("List") || name().equals("Opt")) {
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "int index = parent.getIndexOfChild(this);");
          stream.println(ind(3) +   "if (index >= 0 && parent.childIsNTA(index)) {");
          stream.println(ind(4) +     "node.setParent(null);");
          stream.println(ind(4) +     "return true;");
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "return false;");
          stream.println(ind(2) + "}");
        } else {
          for(Iterator itr = list.iterator(); itr.hasNext();) {
            AttrDecl attr = (AttrDecl)itr.next();
            // NTAs
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
                  && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {

              if (attr.getNumParameter() > 0) {
                stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
                stream.println(ind(3) +   "for (int index = 0; i < " + attr.attributeSignature() + 
                                                "_list.numChildren; i++;) {");
                stream.println(ind(4) +     "ASTNode value = " + attr.attributeSignature() + 
                                                "_list.children[index];");              
                stream.println(ind(4) +     "if (value == node) {");
                stream.println(ind(5) +       attr.attributeSignature() + "_list.removeChild(index);");
                String u = attr.resetVisit() + attr.resetCache();
                u = u.replaceAll("#NAME#", attr.attributeSignature());
                stream.print(u);
                stream.println(ind(5) +       "return true;");
                stream.println(ind(4) +     "}");
                stream.println(ind(3) +   "}");
                stream.println(ind(2) + "}");
              } else {
                Components comp = attr.findCorrespondingNTA();
                if (comp == null || !(comp instanceof OptionalComponentNTA || comp instanceof ListComponentsNTA)) {
                  stream.println(ind(2) + "if (" + attr.attributeSignature() + "_value == node) {");
                  stream.println(ind(3) +   attr.attributeSignature() + "_value.setParent(null);");
                  String u = attr.resetVisit() + attr.resetCache();
                  u = u.replaceAll("#NAME#", attr.attributeSignature());
                  stream.print(u);
                  stream.println(ind(2) + "}");
                }
              }
            }
          }
        }
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}"); 
      }
      // end methods: inc_flush_NTA

      // method: inc_flushRegion
      if (ASTNode.incrementalLevelRegion && (isRegionRoot() || name().equals("ASTNode"))) {
        stream.println(ind + "public void " + name() + ".inc_flushRegion() {");
        if (isRegionRoot()) {
          if (!name().equals("ASTNode")) 
            stream.println(ind(2) + "super.inc_flushRegion();");
          // check of this is an NTA at the parent
          stream.println(ind(2) + "boolean regionRemoved = false;");
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "regionRemoved = parent.inc_flush_NTA(this);");
          stream.println(ind(2) + "}");
          // check if this is a rewritten child of the parent, 
          // need to recheck parent in case this was a NTA an it was removed
          stream.println(ind(2) + "if (parent != null) {");
          stream.println(ind(3) +   "regionRemoved |= parent.inc_flush_child(this);");
          stream.println(ind(2) + "}");
          stream.println(ind(2) + "if (!regionRemoved) {");
          stream.println(ind(3) +   "regionRemoved = inc_flushRegion_rewrites();");
          stream.println(ind(2) + "}");
        }
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "inc_flush();");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child != null && !child.isRegionRoot()) {");
          stream.println(ind(4) +     "child.inc_flushRegion();");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        }
        stream.println(ind + "}"); 
      }
      // end method: inc_flushRegion

      // method: inc_flushRegion_rewrites
      if (ASTNode.incrementalLevelRegion) {
        if (name().equals("ASTNode")) {
          stream.println(ind + "public boolean " + name() + ".inc_flushRegion_rewrites() {");
          stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {"); 
          stream.println(ind(3) +   "ASTNode child = children[i];");
          stream.println(ind(3) +   "if (child == null) continue;");
          stream.println(ind(3) +   "// rewritten child");
          stream.println(ind(3) +   "if (rewritten_children != null && i < rewritten_children.length && " +
                                         "rewritten_children[i]) {");
          stream.println(ind(4) +     "if (!inc_restoreInitialForIndex(i)) {");
          stream.println(ind(5) +       "return false;");
          stream.println(ind(4) +     "}");
          // not rewritten child
          stream.println(ind(3) +   "}");
          stream.println(ind(3) +   "// not rewritten child");
          stream.println(ind(3) +   "else {");
          stream.println(ind(4) +     "if (!child.inc_flushRegion_rewrites()) {");
          stream.println(ind(5) +       "return false;");
          stream.println(ind(4) +     "}");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}"); 
          stream.println(ind(2) + "return true;");
          stream.println(ind + "}"); 
        }
      }      
      // end method: inc_flushRegion_rewrites
    }

  }

  // ES_2011-09-20: Code generation for incremental evaluation, change strategy: flush
  public void ASTDecl.jjtGenIncrementalChangeFlush(PrintWriter stream) {

    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind(2) + "inc_flushRegion();");
    }

    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "inc_flush();");
    } 

    if (ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelParam) {

    // children/rewrites
    if (name().equals("ASTNode")) {
      // stream.println("    if (attrID.equals(\"getChild\") && !state().IN_REWRITE_EVAL) {");
      stream.println(ind(2) + "if (attrID.equals(\"getChild\")) {");
      if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) +   "int i = (Integer)_parameters;");
      }
      if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) +   "for (int i = 0; i < numChildren; i++) {");
      }
      stream.println(ind(4) +     "if (rewritten_children != null && i < rewritten_children.length && rewritten_children[i]) {");
      // make sure this condition is false before calling notify, there may be a circular dependency resulting in a double
      // flush otherwise, a double flush will cause null to be moved in as the initial child
      stream.println(ind(5) +       "rewritten_children[i] = false;");
      stream.println(ind(5) +       "children[i].inc_resetRewrites();");
      // outer rewrites
      stream.println(ind(5) +       "// outer rewrites");
      stream.println(ind(5) +       "if (init_children[i] != null) {");
      stream.println(ind(6) +         "// set up change");
      stream.println(ind(6) +         "ASTNode oldChild = children[i];");
      stream.println(ind(6) +         "ASTNode newChild = init_children[i];");
      stream.println(ind(6) +         "// make change");
      stream.println(ind(6) +         "oldChild.inc_throwAway();");
      stream.println(ind(6) +         "children[i] = newChild;");
      stream.println(ind(6) +         "init_children[i] = null;");
      stream.println(ind(6) +         "// set parents and notify");
      stream.println(ind(6) +         "newChild.setParent(this);");
      if (ASTNode.incrementalLevelParam) stream.println(ind(6) + "getChild_handler[i].notifyDependencies();");    
      if (ASTNode.incrementalLevelAttr) stream.println(ind(6) + "getChild_handler.notifyDependencies();");    
      stream.println(ind(5) +       "}");
      // inner rewrites
      stream.println(ind(5) +       "// inner rewrites");
      stream.println(ind(5) +       "else {");
      stream.println(ind(6) +         "inc_restoreEnclosingRewrite();");
      stream.println(ind(5) +       "}");
      stream.println(ind(4) +     "}");
      if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) +   "}");
      }      
      stream.println(ind(2) + "}");
    }

    // Collect attributes: syn then inh
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrDecl attr = getSynEq(k).decl();
      if (attr != null && (attr.getLazy() || attr.isCircular())) 
        list.add(attr);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      if (attr != null && (attr.getLazy() || attr.isCircular())) 
        list.add(attr);
    }

    // Add attribute code: flush attributes
    boolean first = true;
    for(Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      // start match attribute statement
      if (ASTNode.incrementalLevelParam) {
        stream.print(ind(2) + (first ? "" : "else "));
        stream.print("if (" + "attrID.equals(\"" + attr.attributeSignature() + "\")");
        if (attr.getNumParameter() > 0) 
          stream.print(" && " + attr.attributeSignature() + "_values != null" + 
            " && " + attr.attributeSignature() + "_values.containsKey(_parameters)");
        else stream.print(" && " + attr.attributeSignature() + "_computed");
        stream.println(") {");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.print(ind(2) + (first ? "" : "else "));
        stream.print("if (attrID.equals(\"" + attr.attributeSignature() + "\")");
        if (attr.getNumParameter() > 0) {
          stream.print(" && " + attr.attributeSignature() + "_values != null" + 
            " && !" + attr.attributeSignature() + "_values.isEmpty()");  
        } else stream.println(" && " + attr.attributeSignature() + "_computed");
        stream.println(") {");
      }
      // handle parameterized attributes
      if (attr.getNumParameter() > 0) {
        if (ASTNode.incrementalLevelParam) {
          // handler NTA
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(3) + attr.type() + " value = (" + attr.type() + ")" + 
                  attr.attributeSignature() + "_values.remove(_parameters);");                 
              stream.println(ind(3) + "for (int i = 0; i < " + attr.attributeSignature() + "_list.children.length; i++) {");
              stream.println(ind(4) +   "ASTNode child = " + attr.attributeSignature() + "_list.children[i];");
              stream.println(ind(4) +   "if (child != null && value == child) {");
              stream.println(ind(5) +     attr.attributeSignature() + "_list.removeChild(i);");
              stream.println(ind(5) +     "break;");
              stream.println(ind(4) +   "}");
              stream.println(ind(3) + "}");
          } else {
            stream.println(ind(3) + attr.attributeSignature() + "_values.remove(_parameters);"); 
          }
        } else {
          // handler NTA
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() 
              && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +     attr.attributeSignature() + "_list.setParent(null);");
              stream.println(ind(2) + "}");
          }
          String u = attr.resetVisit() + attr.resetCache();
          u = u.replaceAll("#NAME#", attr.attributeSignature());
          stream.print(u);              
        }
      } else {
        // handle NTAs
        if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          stream.println(ind(3) + "if (" + attr.attributeSignature() + "_value instanceof ASTNode) {");
          stream.println(ind(4) + attr.attributeSignature() + "_value.setParent(null);");
          stream.println(ind(3) + "}");
        }
        String u = attr.resetVisit() + attr.resetCache();
        u = u.replaceAll("#NAME#", attr.attributeSignature());
        stream.print(u);
      }
      // notify
      if (ASTNode.incrementalLevelParam) {
        if (attr.getNumParameter() > 0) {
          stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + 
                                      attr.attributeSignature() + "_handler.remove(_parameters);");
          stream.println(ind(3) +   "handler.notifyDependencies();");
          stream.println(ind(3) +   "handler.throwAway();");
        } else {
          stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
        }
      } 
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
      }
      
      stream.println(ind(2) + "}");      // end match statement
      first = false;
    }  
    }

  }


  // ES_2011-09-20: Code generation for incremental evaluation, 
  public void ASTDecl.jjtGenIncrementalReactToASTChange(PrintWriter stream) {

    /*
    if (ASTNode.incrementalDebug) {

      // method: inc_clearDepsInTree
      stream.println(ind + "public void " + name() + ".inc_clearDepsInTree() {");
      if (name().equals("ASTNode")) {
        if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.clearDependants();");
        stream.println(ind(2) + "numChildren_handler.clearDependants();");
        stream.println(ind(2) + "for (int i = 0; i < numChildren; i++) {");
        stream.println(ind(3) +   "if (!childIsNTA(i) && getChild_handler[i].hasDependants()) {");
        stream.println(ind(4) +     "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(4) +     "getChild_handler[i].clearDependants();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.clearDependants();");
        stream.println(ind(2) + "numChildren_handler.clearDependants();");
        stream.println(ind(2) + "if (getChild_handler.hasDependants()) {");
        stream.println(ind(3) +   "getChild_handler.clearDependants();");
        stream.println(ind(3) +   "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(4) +     "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.clearDependants();");
        stream.println(ind(2) + "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(3) +   "getChildNoTransform(i).inc_clearDepsInTree();");
        stream.println(ind(2) + "}");
        }
      } else {
        stream.println(ind(2) + "super.inc_clearDepsInTree();");
        if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
 	    		Components comp = getComponents(c);
 	    		if (!(comp instanceof TokenComponent)) continue;
          stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
	    	  stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.clearDependants();");
     			stream.println(ind(2) + "}");
      	}
        }
        // collect attributes: syn then inh
        ArrayList list = new ArrayList();
        for(int k = 0; k < getNumSynEq(); k++) {
          AttrDecl attr = getSynEq(k).decl();
          if (attr != null && (attr.getLazy() || attr.isCircular())) 
            list.add(attr);
        }
        for(int k = 0; k < getNumInhDecl(); k++) {
          AttrDecl attr = getInhDecl(k);
          if (attr != null && (attr.getLazy() || attr.isCircular())) 
            list.add(attr);
        }
        // attributes
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          if (ASTNode.incrementalLevelParam) {
            if (attr.getNumParameter() > 0) {
    	      stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                    "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.clearDependants();");
            stream.println(ind(2) + "}");
            } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.clearDependants();");
    	      stream.println(ind(2) + "}");
      	    }
          }
          if (ASTNode.incrementalLevelAttr) {
      	    stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
      	    stream.println(ind(3) +   attr.attributeSignature() + "_handler.clearDependants();");
       	    stream.println(ind(2) + "}");
          }
    	  }    
      stream.println(ind + "}");  // end method: inc_clearDepsInTree
    }
    */


    // method: inc_notifyForRemove
    if (name().equals("ASTNode")) {  
      stream.println(ind + "public void ASTNode.inc_notifyForRemove() {");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.notifyDependencies();");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.flushRegion();");
      }
      if (ASTNode.incrementalLevelRegion) {
        stream.println(ind(2) + "handler().flushRegion();");
      }
      stream.println(ind + "}"); 
    } 
    // end method: inc_notifyForRemove

  }



  // ES_2011-11-28: Code generation for incremental evaluation, state handling
  public void ASTDecl.jjtGenIncrementalState(PrintWriter stream) {

    // states
    if (name().equals("ASTNode")) {
    stream.println(ind + "public static final int ASTNode.inc_CREATED = 0;");  
    stream.println(ind + "public static final int ASTNode.inc_CLONED = 1;");  
    stream.println(ind + "public static final int ASTNode.inc_LIVE = 2;");  
    stream.println(ind + "public static final int ASTNode.inc_GARBAGE = 3;");  
    stream.println(ind + "public int ASTNode.inc_state = inc_CREATED;");  
    }

    // Collect attributes: syn then inh
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrDecl attr = getSynEq(k).decl();
      if (attr != null && (attr.getLazy() || attr.isCircular())) 
        list.add(attr);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      if (attr != null && (attr.getLazy() || attr.isCircular())) 
        list.add(attr);
    }


    // Method: inc_changeState
    stream.println(ind + "public void " + name() + ".inc_changeState(int newState) {");
    if (name().equals("ASTNode")) {
      stream.println(ind(2) + "inc_state = newState;");
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.changeState(newState);");
        stream.println(ind(2) + "numChildren_handler.changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (getChild_handler[i] != null)");
        stream.println(ind(4) +     "getChild_handler[i].changeState(newState);");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.changeState(newState);");
        stream.println(ind(2) + "numChildren_handler.changeState(newState);");
        stream.println(ind(2) + "getChild_handler.changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelRegion) {
        stream.println(ind(2) + "if (isRegionRoot()) handler().changeState(newState);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_changeState(newState);");
        stream.println(ind(2) + "}");
      }
    } else {
      stream.println(ind(2) + "super.inc_changeState(newState);");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
 	    	  Components comp = getComponents(c);
 	    	  if (comp instanceof TokenComponent) {
	    	    stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
	    		  stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.changeState(newState);");
	    			stream.println(ind(2) + "}");

 	    		}
 	    	}
      }
      // attributes
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        // handlers
        if (ASTNode.incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
    	      stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                  "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.changeState(newState);");
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.changeState(newState);");
    	      stream.println(ind(2) + "}");
    	    }
        }
        if (ASTNode.incrementalLevelAttr) {
    	    stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
    	    stream.println(ind(3) +   attr.attributeSignature() + "_handler.changeState(newState);");
    	    stream.println(ind(2) + "}");
        }
        // values for NTAs
        if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
            !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || 
              ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_changeState(newState);");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.inc_changeState(newState);");
              stream.println(ind(2) + "}");
            }
          }
        }
      }    
    }
    stream.println(ind + "}");    // end method: inc_changeState



    // method: inc_throwAway
    stream.println(ind + "public void " + name() + ".inc_throwAway() {");
    stream.println(ind(2) + "inc_state = inc_GARBAGE;");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.throwAway();");
        stream.println(ind(2) + "numChildren_handler.throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (getChild_handler[i] != null)");
        stream.println(ind(4) +     "getChild_handler[i].throwAway();");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.throwAway();");
        stream.println(ind(2) + "numChildren_handler.throwAway();");
        stream.println(ind(2) + "getChild_handler.throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelRegion) {
        stream.println(ind(2) + "if (isRegionRoot()) handler().throwAway();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_throwAway();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_throwAway();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    } else {
      stream.println(ind(2) + "super.inc_throwAway();");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
 	    	  Components comp = getComponents(c);
 	    	  if (comp instanceof TokenComponent) {
	    	    stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
	    		  stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.throwAway();");
	    			stream.println(ind(2) + "}");
 	    		}
 	    	}
      }
      // attributes
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        // handlers
        if (ASTNode.incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
    	      stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                  "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.throwAway();");
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.throwAway();");
    	      stream.println(ind(2) + "}");
    	    }
        }
        if (ASTNode.incrementalLevelAttr) {
    	    stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
    	    stream.println(ind(3) +   attr.attributeSignature() + "_handler.throwAway();");
    	    stream.println(ind(2) + "}");
        }
        // values for NTAs
        if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
            !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || 
              ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_throwAway();");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.inc_throwAway();");
              stream.println(ind(2) + "}");
            }
          }
        }
  	  }    
    }
    stream.println(ind + "}");    
    // end method: inc_throwAway

    /*
    // method: inc_cleanUpGarbage
    stream.println(ind + "public void " + name() + ".inc_cleanUpGarbage() {");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam) {
        stream.println(ind(2) + "getParent_handler.cleanUpGarbage();");
        stream.println(ind(2) + "numChildren_handler.cleanUpGarbage);");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (getChild_handler[i] != null) getChild_handler[i].cleanUpGarbage();");
        stream.println(ind(3) +   "if (child != null) child.inc_cleanUpGarbage();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_cleanUpGarbage();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.cleanUpGarbage();");
        stream.println(ind(2) + "numChildren_handler.cleanUpGarbage();");
        stream.println(ind(2) + "getChild_handler.cleanUpGarbage();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_cleanUpGarbage();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_cleanUpGarbage();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.cleanUpGarbage();");
        stream.println(ind(2) + "for (int i = 0; children != null && i < children.length; i++) {");
        stream.println(ind(3) +   "ASTNode child = children[i];");
        stream.println(ind(3) +   "if (child != null) child.inc_cleanUpGarbage();");
        stream.println(ind(3) +   "if (init_children != null && i < init_children.length && init_children[i] != null) {");
        stream.println(ind(4) +     "init_children[i].inc_cleanUpGarbage();");
        stream.println(ind(3) +   "}");
        stream.println(ind(2) + "}");
      }
    } else {
      stream.println(ind(2) + "super.inc_cleanUpGarbage();");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
 	    	  Components comp = getComponents(c);
 	    	  if (comp instanceof TokenComponent) {
	    	    stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
	    		  stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.cleanUpGarbage();");
	    			stream.println(ind(2) + "}");
 	    		}
 	    	}
      }
      // attributes
      for(Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (ASTNode.incrementalLevelParam) {
          if (attr.getNumParameter() > 0) {
    	      stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                  "_handler.values().iterator(); itr.hasNext();) {");
            stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
            stream.println(ind(3) +   "handler.cleanUpGarbage();");
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
                !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(3) + "if (" + attr.attributeSignature() + "_computed && (" +
                                        attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_cleanUpGarbage();");
              stream.println(ind(3) + "}");
            }
            stream.println(ind(2) + "}");
          } else {
            stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println(ind(3) +   attr.attributeSignature() + "_handler.cleanUpGarbage();");
            if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
                !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
              stream.println(ind(3) + "if (" + attr.attributeSignature() + "_computed && (" +
                                        attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(4) + attr.attributeSignature() + "_value.inc_cleanUpGarbage();");
              stream.println(ind(3) + "}");
            }
    	      stream.println(ind(2) + "}");
    	    }
        }
        if (ASTNode.incrementalLevelAttr) {
    	    stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
    	    stream.println(ind(3) +   attr.attributeSignature() + "_handler.cleanUpGarbage();");
    	    stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
          if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
              !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.inc_cleanUpGarbage();");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.inc_cleanUpGarbage();");
              stream.println(ind(2) + "}");
            }
          }
        }
  	  }    
    }
    stream.println(ind + "}");    
    // end method: inc_cleanUpGarbage
    */
  } // end: jjtGenIncrementalState


  // ES_2011-12-05: Regions for incremental evaluation
  public void ASTDecl.jjtGenIncrementalRegions(PrintWriter stream) {

    // method: isRegionRoot()
    if (ASTNode.incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "public boolean ASTNode.isRegionRoot() {");
        stream.println(ind(2) + "return true;");
        stream.println(ind + "}"); 
      }
    }
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind + "public boolean " + name() + ".isRegionRoot() {");
      if (isRegionRoot())
        stream.println(ind(2) + "return true;");
      else {
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "return false;");
        } else { 
          stream.println(ind(2) + "return super.isRegionRoot();");
        }
      }
      stream.println(ind + "}"); 
    }
    // method end: isRegionRoot()

    // method: regionRoot()
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
        stream.println(ind(2) + "return this;");
        stream.println(ind + "}"); 
      } else {
        stream.println(ind + "public ASTNode " + name() + ".regionRoot() {");
        stream.println(ind(2) + "return parent != null ? parent.regionRoot() : null;");
        stream.println(ind + "}"); 
      }
    }
    // method end: regionRoot()

    // method: handler()
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot()) {
        stream.println(ind + "public ASTNode$DepGraphNode " + name() + ".handler() {");
        stream.println(ind(2) + "return handler;");
        stream.println(ind + "}"); 
      } else {
        stream.println(ind + "public ASTNode$DepGraphNode " + name() + ".handler() {");
        if (name().equals("ASTNode")) {
          stream.println(ind(2) + "ASTNode root = regionRoot();");
          stream.println(ind(2) + "return root != null ? root.handler() : null;");
        } else {
          stream.println(ind(2) + "ASTNode$DepGraphNode h = super.handler();");
          stream.println(ind(2) + "if (h != null) return h;");
          stream.println(ind(2) + "ASTNode root = regionRoot();");
          stream.println(ind(2) + "return root != null ? root.handler() : null;");
        }
        stream.println(ind + "}"); 
      }
    }
    // method end: handler()

    // method: getParent() -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionRoot() && !name().equals("ASTNode")) {
        stream.println(ind + "public ASTNode " + name() + ".getParent() {");
		    stream.println(ind(2) + "// region root");
        stream.println(ind(2) + "ASTNode parent = super.getParent();");
        stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && parent != null)");
        stream.println(ind(3) +   "parent.handler().addDependant(handler);");
        stream.println(ind(2) + "return parent;");
        stream.println(ind + "}");          
      }
    }
    // end method: getParent() -- overloaded for region tracking

    // method: getChild(int) -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
      stream.println(ind + "private boolean " + name() + ".IS_REGION_LEAF = " + isRegionLeaf() + ";");
      stream.println(ind + "private boolean " + name() + ".IS_REGION_ROOT = " + isRegionRoot() + ";");

      if (isRegionLeaf()) {
        if (name().equals("List") || name().equals("Opt")) {
          if(ASTNode.java5) {
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "@SuppressWarnings(\"cast\") public T " + name() + ".getChild(int i) {");
      		  stream.println(ind(2) + "// region leaf");
	    	    stream.println(ind(2) + "ASTNode child = super.getChild(i);");
      		  stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
	      	  stream.println(ind(2) + "}");
	      	  stream.println(ind(2) + "return (T)child;");
            stream.println(ind + "}");    
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
            stream.println(ind + "@SuppressWarnings(\"cast\") public T " + name() + ".getChildNoTransform(int i) {");
      		  stream.println(ind(2) + "// region leaf");
	    	    stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
      		  stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
	      	  stream.println(ind(2) + "}");
	      	  stream.println(ind(2) + "return (T)child;");
            stream.println(ind + "}");    
          } else {
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
      		  stream.println(ind + "public ASTNode " + name() + ".getChild(int i) {");
      		  stream.println(ind(2) + "// region leaf");
	    	    stream.println(ind(2) + "ASTNode child = super.getChild(i);");
      		  stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
	      	  stream.println(ind(2) + "}");
	      	  stream.println(ind(2) + "return child;");
	      	  stream.println(ind + "}");
            stream.println(ind + "/**");
            stream.println(ind + " * @apilevel low-level");
            stream.println(ind + " */");
      		  stream.println(ind + "public ASTNode " + name() + ".getChildNoTransform(int i) {");
      		  stream.println(ind(2) + "// region leaf");
	    	    stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
      		  stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
            stream.println(ind(3) +   "child.handler().addDependant(handler());");
	      	  stream.println(ind(2) + "}");
	      	  stream.println(ind(2) + "return child;");
	      	  stream.println(ind + "}");
          }
        }
        else if (!name().equals("ASTNode")) {
          stream.println(ind + "/**");
          stream.println(ind + " * @apilevel low-level");
          stream.println(ind + " */");
    		  stream.println(ind + "public ASTNode " + name() + ".getChild(int i) {");
    		  stream.println(ind(2) + "// region leaf");
	  	    stream.println(ind(2) + "ASTNode child = super.getChild(i);");
    		  stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
          stream.println(ind(3) +   "child.handler().addDependant(handler());");
	    	  stream.println(ind(2) + "}");
	    	  stream.println(ind(2) + "return child;");
	    	  stream.println(ind + "}");
          stream.println(ind + "/**");
          stream.println(ind + " * @apilevel low-level");
          stream.println(ind + " */");
    		  stream.println(ind + "public ASTNode " + name() + ".getChildNoTransform(int i) {");
    		  stream.println(ind(2) + "// region leaf");
	  	    stream.println(ind(2) + "ASTNode child = super.getChildNoTransform(i);");
    		  stream.println(ind(2) + "if (state().IN_COMPUTATION > 0 && child.isRegionRoot()) {");
          stream.println(ind(3) +   "child.handler().addDependant(handler());");
	    	  stream.println(ind(2) + "}");
	    	  stream.println(ind(2) + "return child;");
	    	  stream.println(ind + "}");
        }
      }
    }
    // end method: getChild(int) -- overloaded for region tracking

    // TODO revisit this method
/*
    // method: removeChild(int) -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionLeaf() && !name().equals("ASTNode")) {
	  	  stream.println(ind + "public void " + name() + ".removeChild(int index) {");
  		  stream.println(ind(2) + "// region leaf");
  		  stream.println(ind(2) + "ASTNode child = getChild(index);");
	  	  stream.println(ind(2) + "if (child.isRegionRoot()) {");
	  	  stream.println(ind(3) +   "ASTNode$DepGraphNode handler = handler();");
	  	  stream.println(ind(3) +   "if (handler != null) handler.flushRegion();");
	  	  stream.println(ind(2) + "}");
	  	  stream.println(ind(2) + "super.removeChild(index);");
	  	  stream.println(ind + "}");
      }
    }
    // end method: removeChild(int) -- overloaded for region tracking

    // TODO revisit this method
    // method: insertChild(ASTNode,int) -- overloaded for region tracking
    if (ASTNode.incrementalLevelRegion) {
      if (isRegionLeaf() && !name().equals("ASTNode")) {
  		  stream.println("    public void " + name() + ".insertChild(ASTNode node, int index) {");
  		  stream.println("      // region leaf");
	  	  stream.println("      if (node.isRegionRoot()) {");
	  	  stream.println(ind(3) +   "ASTNode$DepGraphNode handler = handler();");
	  	  stream.println(ind(3) +   "if (handler != null) handler.flushRegion();");
	  	  stream.println("      }");
	  	  stream.println("      super.insertChild(node, index);");
	  	  stream.println("    }");
      }        
    }
    // end method: insertChild(ASTNode,int) -- overloaded for region tracking
*/

  } // end: jjtGenIncrementalRegions
  

  // ES_2011-09-20: Debug code generation for incremental evaluation
  public void ASTDecl.jjtGenIncrementalDebug(PrintWriter stream) {

    // method: relativeNodeID()          
    if (name().equals("ASTNode")) {
      stream.println(ind + "public String ASTNode.relativeNodeID() {");
      stream.println(ind(2) + "ASTNode parent = this.parent;");
      stream.println(ind(2) + "StringBuffer buf = new StringBuffer();");
      stream.println(ind(2) + "int index = -1;");
      stream.println(ind(2) + "if (parent != null) {");
      stream.println(ind(3) +   "buf.append(parent.relativeNodeID() + \"/\");");
      stream.println(ind(3) +   "for (int i = 0; i < parent.children.length; i++) {");
      stream.println(ind(4) +     "if (parent.children[i] != null && " + 
                                        "parent.children[i] == this && " + 
                                        "!parent.childIsNTA(i)) {");
      stream.println(ind(5) +       "index = i;");
      stream.println(ind(5) +       "break;");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "buf.append(getClass().getSimpleName());");
      stream.println(ind(2) + "if (index > -1) {");
      stream.println(ind(3) +   "buf.append(\"[\" + index + \"]\");");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return buf.toString();");
      stream.println(ind + "}");
    }
    // end method: relativeNodeID()          
    
    // method: printParamList(List)
    if (name().equals("ASTNode")) {
      stream.println(ind + "protected String ASTNode.printParamList(java.util.List paramList) {");
      stream.println(ind(2) + "StringBuffer buf = new StringBuffer();");
      stream.println(ind(2) + "for (java.util.Iterator itr = paramList.iterator(); itr.hasNext();) {");
      stream.println(ind(3) +   "Object o = itr.next();");
      stream.println(ind(3) +   "if (o instanceof ASTNode) {");
      stream.println(ind(4) +     "buf.append(((ASTNode)o).relativeNodeID());");
      stream.println(ind(3) +   "} else {");
      stream.println(ind(4) +     "buf.append(o.toString());");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "buf.append(\",\");");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return buf.toString();");
      stream.println(ind + "}");    
    }
    // end method: printParamList(List)
        
    // method: dumpCachedValues()
    stream.println(ind + "public void " + name() + ".dumpCachedValues() {");
    if (name().equals("ASTNode")) {
      // rewrite code
      stream.println(ind(2) + "for (int k = 0; rewritten_children != null && k < rewritten_children.length; k++) {");
      stream.println(ind(3) +   "if (rewritten_children[k]) {");
      stream.println(ind(4) +     "System.out.println(children[k].relativeNodeID() + " + 
                                      "\" rewritten, initial=\" + " +
                                  "(init_children[k] != null ? init_children[k].relativeNodeID():null));");
      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
     //
    }
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq attrEq = getSynEq(k);
    	AttrDecl attr = attrEq.decl();
      String u = attr.dumpCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.println(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      InhDecl attr = getInhDecl(k);
      String u = attr.dumpCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.println(u);
    }
    stream.println(ind(2) + "// TODO: dump collection values");
    if (!name().equals("ASTNode")) {
      stream.println(ind(2) + "super.dumpCachedValues();");
    }
    stream.println(ind + "}");     
    // end method: dumpCachedValues()     
      

    // method: dumpDependencies()
    stream.println(ind + "public void " + name() + ".dumpDependencies() {");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        stream.println(ind(2) + "getParent_handler.dumpDeps();");
        stream.println(ind(2) + "numChildren_handler.dumpDeps();");
        if (ASTNode.incrementalLevelParam) {
          stream.println(ind(2) + "for (int k = 0; getChild_handler != null && k < getChild_handler.length; k++) {");
          stream.println(ind(3) +   "if (getChild_handler[k] != null) {");
          stream.println(ind(4) +     "getChild_handler[k].dumpDeps();");
          stream.println(ind(3) +   "}");
          stream.println(ind(2) + "}");
        }
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind(2) + "getChild_handler.dumpDeps();");
        }
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println(ind(2) + "handler.dumpDeps();");
      }
    } 
    if (ASTNode.incrementalLevelRegion && isRegionRoot()) {
      stream.println(ind(2) + "handler.dumpDeps();");
    }
    // collect attributes
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynEq(); k++) {
 	    AttrDecl attr = getSynEq(k).decl();
 	    if (attr.getLazy() || attr.isCircular()) 
        list.add(attr);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      InhDecl attr = getInhDecl(k);
 	    if (attr.getLazy() || attr.isCircular()) 
        list.add(attr);
    }
    // tokens
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      for (int c = 0; c < getNumComponents(); c++) {
 	  	  Components comp = getComponents(c);
 	  	  if (comp instanceof TokenComponent && !comp.isNTA()) {
	  	    stream.println(ind(2) + "if (get" + ((TokenComponent)comp).getTokenId().getID() + "_handler != null) {");
	  		  stream.println(ind(3) +   "get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.dumpDeps();");
	  			stream.println(ind(2) + "}");
 	  		}
 	  	}
    }
    // attributes
    for(Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      // handlers
      if (ASTNode.incrementalLevelParam) {
        if (attr.getNumParameter() > 0) {
  	      stream.println(ind(2) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                "_handler.values().iterator(); itr.hasNext();) {");
          stream.println(ind(3) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)itr.next();");
          stream.println(ind(3) +   "handler.dumpDeps();");
          stream.println(ind(2) + "}");
        } else {
          stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
          stream.println(ind(3) +   attr.attributeSignature() + "_handler.dumpDeps();");
  	      stream.println(ind(2) + "}");
  	    }
      }
      if (ASTNode.incrementalLevelAttr) {
  	    stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
   	    stream.println(ind(3) +   attr.attributeSignature() + "_handler.dumpDeps();");
   	    stream.println(ind(2) + "}");
      }
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // values for NTAs
        if ((attr.isNTA() || attr.getNTA()) && !attr.isPrimitive() && 
            !(attr.type().equals("String") || attr.type().equals("java.lang.String"))) {
          if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
            if (attr.getNumParameter() > 0) {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_list != null) {");
              stream.println(ind(3) +   attr.attributeSignature() + "_list.dumpDependencies();");
              stream.println(ind(2) + "}");
            } else {
              stream.println(ind(2) + "if (" + attr.attributeSignature() + "_computed && (" +
                                      attr.attributeSignature() + "_value instanceof ASTNode)) {");
              stream.println(ind(3) + attr.attributeSignature() + "_value.dumpDependencies();");
              stream.println(ind(2) + "}");
            }
          }
        }
      }
    }
    stream.println(ind(2) + "// TODO: dump collection values");
    // super call
    if (!name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelRegion) {
        if (!isRegionRoot()) 
          stream.println(ind(2) + "super.dumpDependencies();");
      } else {
          stream.println(ind(2) + "super.dumpDependencies();");
      }
    }
    stream.println(ind + "}");  
    // end method: dumpDependencies()

  }

  // ES_2011-09-06: Code generation for incremental evaluation, dependency node class / handler class
  public void Grammar.jjtGenASTNode$DepGraphNode(PrintWriter stream, String parserName) {
    // class: ASTNode$DepGraphNode
    stream.println("  static public class ASTNode$DepGraphNode {");
    // add listeners/dependencies from another handler, used in rewrites
    stream.println("    public void addSetsFrom(ASTNode$DepGraphNode node) {");
    stream.println("      fListenerSet.addAll(node.fListenerSet);");
    stream.println("      fDependencySet.addAll(node.fDependencySet);");
    stream.println("    }");
    // state
    stream.println("    protected int fState = ASTNode.inc_CREATED;");
    stream.println("    public void changeState(int newState) {");
    stream.println("      fState = newState;");
    stream.println("    }");
    stream.println("    public void throwAway() {");
    stream.println("      fState = ASTNode.inc_GARBAGE;");
    stream.println("      clearDependants();");
    stream.println("    }");
    stream.println("    public void keepAlive() {");
    stream.println("      fState = ASTNode.inc_LIVE;");
    stream.println("    }");
    stream.println("    public boolean isGarbage() {");
    stream.println("      return fState == ASTNode.inc_GARBAGE;");
    stream.println("    }");
    stream.println("    public boolean isCreated() {");
    stream.println("      return fState == ASTNode.inc_CREATED;");
    stream.println("    }");
    stream.println("    public boolean isCloned() {");
    stream.println("      return fState == ASTNode.inc_CLONED;");
    stream.println("    }");
    stream.println("    public boolean isLive() {");
    stream.println("      return fState == ASTNode.inc_LIVE;");
    stream.println("    }");
    // clean up
    stream.println("    public boolean visitedDuringCleanup = false;");
    stream.println("    public static int nbr_cleanup = 0;");
    stream.println("    public void cleanUpGarbage() {");
    stream.println("      visitedDuringCleanup = true;");
    stream.println("      nbr_cleanup++;");
    stream.println("      // Clean up garbage");
    stream.println("      Iterator<ASTNode$DepGraphNode> itr = fListenerSet.iterator();");
    stream.println("      while (itr.hasNext()) {");
    stream.println("        ASTNode$DepGraphNode cur = itr.next();");
    stream.println("        if (cur.isGarbage()) {");
    stream.println("          itr.remove();");
    stream.println("        }");
    stream.println("      }");
    stream.println("    }");
    stream.println("    public static LinkedList<ASTNode$DepGraphNode> createdHandlers = new LinkedList<ASTNode$DepGraphNode>();");
    stream.println("    public static void doCleanUp() {");
    stream.println("      Iterator itr = createdHandlers.iterator();");
    stream.println("      while (itr.hasNext()) {");
    stream.println("        ASTNode$DepGraphNode node = (ASTNode$DepGraphNode)itr.next();");
    stream.println("        if (node.isGarbage() || node.isCreated())");
    stream.println("          itr.remove();");
    stream.println("        else node.cleanUpGarbage();");
    stream.println("      }");
    stream.println("    }");
    // level: node, attr, param all need a node to store the dependency node in
	  stream.println("    public ASTNode fNode;");
    // level: param needs both an attr ID and a param ID
    if (ASTNode.incrementalLevelParam) {
	    stream.println("    public String fAttrID;");
	    stream.println("    protected Object fParams;");
      stream.println("    public ASTNode$DepGraphNode(ASTNode node, String attrID, Object params) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = attrID;");
      stream.println("      fParams = params;");
      stream.println("      fState = node.inc_state;");
      stream.println("      createdHandlers.add(this);");
      stream.println("    }");
      stream.println("    public ASTNode$DepGraphNode(ASTNode$DepGraphNode handler, ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = handler.fAttrID;");
      stream.println("      fParams = handler.fParams;");
      stream.println("      fState = node.inc_state;");
      stream.println("      createdHandlers.add(this);");
      stream.println("    }");
      stream.println("    public void setParams(Object params) {");
      stream.println("      fParams = params;");
      stream.println("    }");
    }
    // level: attr also needs an attr ID 
    if (ASTNode.incrementalLevelAttr) {
	    stream.println("    public String fAttrID;");
      stream.println("    public ASTNode$DepGraphNode(ASTNode node, String attrID) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = attrID;");
      stream.println("      fState = node.inc_state;");
      stream.println("      createdHandlers.add(this);");
      stream.println("    }");
      stream.println("    public ASTNode$DepGraphNode(ASTNode$DepGraphNode handler, ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = handler.fAttrID;");
      stream.println("      fState = node.inc_state;");
      stream.println("      createdHandlers.add(this);");
      stream.println("    }");
    }
    // level: node, region
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
      stream.println("    public ASTNode$DepGraphNode(ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fState = node.inc_state;");
      stream.println("      createdHandlers.add(this);");
      stream.println("    }");    
      stream.println("    public ASTNode$DepGraphNode(ASTNode$DepGraphNode handler, ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("      fState = node.inc_state;");
      stream.println("      createdHandlers.add(this);");
      stream.println("    }");
    }
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion) {
      stream.println("    public void flushRegion() {");
      stream.println("      dependencyChanged();");
      stream.println("    }");          
    }
    // behavior generic for any kind of dependency region
  	stream.println("    public java.util.HashSet<ASTNode$DepGraphNode> fListenerSet = " +
                   "new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("    public boolean hasDependants() {");
    stream.println("        return !fListenerSet.isEmpty();");
    stream.println("    }");
    stream.println("    public java.util.HashSet<ASTNode$DepGraphNode> fDependencySet = " +
                   "new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("    public void clearDependants() {");
    stream.println("      for (ASTNode$DepGraphNode node : fListenerSet) {");
    stream.println("        node.removeDependency(this);");
    stream.println("      }");
    stream.println("      fListenerSet.clear();");
    stream.println("    }");
    stream.println("    public void clearDependencies() {");
    stream.println("      for (ASTNode$DepGraphNode node : fDependencySet) {");
    stream.println("        node.removeDependant(this);");
    stream.println("      }");
    stream.println("      fDependencySet.clear();");
    stream.println("    }");
    stream.println("    public void addDependency(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fDependencySet.add(node);");
//    stream.println("      }");
    stream.println("    }");
    stream.println("    public void removeDependency(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fDependencySet.remove(node);");
//    stream.println("      }");
    stream.println("    }");
    stream.println("    public void addDependant(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fListenerSet.add(node);");
    stream.println("      node.addDependency(this);");
//    stream.println("      }");
    stream.println("    }");
    stream.println("    public void removeDependant(ASTNode$DepGraphNode node) {");
//    stream.println("      if (node != this) {");
    stream.println("      fListenerSet.remove(node);");
    stream.println("    }");
    //}
    stream.println("    private boolean visited = false;");
    stream.println("    public void notifyDependencies() {");
    stream.println("      // Notify and remove listeners");
    stream.println("      if (!visited) {");
    stream.println("        visited = true;");
    stream.println("        java.util.HashSet<ASTNode$DepGraphNode> k = fListenerSet;");
    stream.println("        fListenerSet = new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("        for (ASTNode$DepGraphNode node : k) {");
    stream.println("          node.dependencyChanged();");
    stream.println("        }");
    stream.println("        visited = false;");
    stream.println("      }");
    stream.println("    }");
    // React to change
    stream.println("    private boolean visitedChange = false;");
    stream.println("    public void dependencyChanged() {");
    stream.println("      if (!visitedChange) {");
    stream.println("        visitedChange = true;");
    stream.println("      // Remove dependencies");
    stream.println("      java.util.HashSet<ASTNode$DepGraphNode> k = fDependencySet;");
    stream.println("      fDependencySet = new java.util.HashSet<ASTNode$DepGraphNode>(4);");
    stream.println("      for (ASTNode$DepGraphNode node : k) {");
    stream.println("        node.removeDependant(this);");
    stream.println("      }");
    if (ASTNode.incrementalLevelParam)
      stream.println("      fNode.reactToDependencyChange(fAttrID, fParams);");
    if (ASTNode.incrementalLevelAttr) 
      stream.println("      fNode.reactToDependencyChange(fAttrID);");
    if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion)
      stream.println("      fNode.reactToDependencyChange();");
    stream.println("        visitedChange = false;");
    stream.println("      }");
    stream.println("    }");
    // Debugging methods:
    if (ASTNode.incrementalDebug) {
      stream.println("    public void dumpDeps() {");
      stream.println("      TreeSet<String> sorted = new TreeSet<String>();");
      stream.println("      for (ASTNode$DepGraphNode node : fListenerSet) {");
      stream.println("        sorted.add(node.toString());");
      stream.println("      }");
      stream.println("      for (String s : sorted) {");
      stream.println("        System.out.println(\"dep(\" + s + \" -> \" + this + \")\");");
      stream.println("      }");
      stream.println("    }");
      stream.println("    public String toString() {");
      if (ASTNode.incrementalLevelParam) 
        stream.println("      return fNode.relativeNodeID() + \":\" + fAttrID + " +
            "(fParams != null ? (\"[\" + (fParams instanceof ASTNode ? " +
            "((ASTNode)fParams).relativeNodeID() : fParams) + \"]\") : \"\");");
      if (ASTNode.incrementalLevelAttr)
        stream.println("      return fNode.relativeNodeID() + \":\" + fAttrID;");
      if (ASTNode.incrementalLevelNode || ASTNode.incrementalLevelRegion)
        stream.println("      return fNode.relativeNodeID();");
      stream.println("    }");
    }
    stream.println("  }"); // End ASTNode$DepGraphNode
  }


  syn boolean ASTDecl.rewriteWithNoPhaseCondition() {
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() == null)
        return true;
      String condition = getRewrite(i).getCondition().unparse();
      if(condition.indexOf("inRewritePhase") == -1 && condition.indexOf("inExactRewritePhase") == -1)
        return true;
    }
    return superClass() instanceof ASTDecl && ((ASTDecl)superClass()).rewriteWithNoPhaseCondition();
  }

  syn java.util.Set ASTDecl.rewritePhaseConditions() {
    java.util.Set set = new java.util.LinkedHashSet();
    Pattern p = Pattern.compile("inRewritePhase\\([\\w\\.]*\\)|inExactRewritePhase\\([\\w\\.]*\\)");
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() != null) {
        String condition = getRewrite(i).getCondition().unparse();
        Matcher m = p.matcher(condition);
        while(m.find()) {
          String match = m.group();
          set.add(match);
        }
      }
    }
    if(superClass() instanceof ASTDecl)
      set.addAll(((ASTDecl)superClass()).rewritePhaseConditions());
    return set;
  }

  public abstract void Components.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl);

  String ListComponents.setNameListComment() {
    return ind + "/**\n" +
      ind + " * Setter for #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNumNameComment() {
    return ind + "/**\n" +
      ind + " * @return number of children in #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNameComment() {
    return ind + "/**\n" +
      ind + " * Getter for child in list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.addNameComment() {
    return ind + "/**\n" +
      ind + " * Add element to list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.setNameComment() {
    return ind + "/**\n" +
      ind + " * Setter for child in list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNameListComment() {
    return ind + "/**\n" +
      ind + " * Getter for list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }


  public void ListComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String s;
    String name = decl.name();
    // Generate getNum- and get-method for the list component
    s = setNameListComment() +
      ind + "public void #HOST#.set#NAME#List(#LISTTYPE# list) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "setChild(list, #INDEX#);\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      //ind + "private int #HOST#.getNum#NAME# = 0;\n" +
      getNumNameComment() +
      ind + "public int #HOST#.getNum#NAME#() {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return get#NAME#List().getNumChild();\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      getNameComment() +
      "#ANNOTATIONS#" +
      ind + "public #TYPE# #HOST#.get#NAME#(int i) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return (#TYPE#)get#NAME#List().getChild(i);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      addNameComment() +
      ind + "public void #HOST#.add#NAME#(#TYPE# node) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = (parent == null || state == null) ? get#NAME#ListNoTransform() : get#NAME#List();\n" +
      ind(2) + "list.addChild(node);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      ind + "/**\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n" +
      ind + "public void #HOST#.add#NAME#NoTransform(#TYPE# node) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = get#NAME#ListNoTransform();\n" +
      ind(2) + "list.addChild(node);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node, int i) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = get#NAME#List();\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "list.setChild(node, i);\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(ASTNode.java5) {
      s +=
        ind + "/**\n" +
        ind + " * Getter for #NAME# list.\n" +
        ind + " * @apilevel high-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#s() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return get#NAME#List();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#sNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return get#NAME#ListNoTransform();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    if(!isNTA()) {
      s +=
        getNameListComment() +
        "#ANNOTATIONS#" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#List() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "#LISTTYPE# list = (#LISTTYPE#)getChild(#INDEX#);\n" +
        ind(2) + "list.getNumChild();\n" +
        ind(2) + "return list;\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" + 
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#ListChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#LISTTYPE#", ASTNode.java5 ? "List<" + getId().type() + ">" : "List");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }

  String OptionalComponent.setNameOptComment() {
    return ind + "/**\n" +
      ind + " * Setter for #NAME#Opt\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.hasNameComment() {
    return ind + "/**\n" +
      ind + " * Does this node have a #NAME# child?\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.getNameComment() {
    return ind + "/**\n" +
      ind + " * Getter for optional child #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.setNameComment() {
    return ind + "/**\n" +
      ind + " * Setter for optional child #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.getNameOptComment() {
    return ind + "/**\n" +
      ind + " * Getter for #NAME#Opt\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n";
  }

  public void OptionalComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate has- and get-method for the optional component
    s = setNameOptComment() +
      ind + "public void #HOST#.set#NAME#Opt(#OPTTYPE# opt) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "setChild(opt, #INDEX#);\n" + 
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      hasNameComment() +
      ind + "public boolean #HOST#.has#NAME#() {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return get#NAME#Opt().getNumChild() != 0;\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      getNameComment() +
      "#ANNOTATIONS#" +
      ind + "public #TYPE# #HOST#.get#NAME#() {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return (#TYPE#)get#NAME#Opt().getChild(0);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "get#NAME#Opt().setChild(node, 0);\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(!isNTA()) {
      s +=
        getNameOptComment() +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#Opt() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChild(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#OptChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#OPTTYPE#", ASTNode.java5 ? "Opt<" + getId().type() + ">" : "Opt");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }


  String TokenComponent.setIDComment() {
    return ind + "/**\n" +
      ind + " * Setter for lexeme #ID#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String TokenComponent.getIDComment() {
    return ind + "/**\n" +
      ind + " * Getter for lexeme #ID#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  private boolean TokenComponent.called = false;
  public void TokenComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    StringBuffer buf = new StringBuffer();
    buf.append(setIDComment());
    // Generate attribute, get- and set-method for the token string
    buf.append(
        // ES_2011-09-20: Code generation for incremental evaluation
        (ASTNode.incremental ? jaddGenIncrementalTokenHandler() : "") +
        //
        ind + "public void #HOST#.set#ID#(#TYPE# value) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        // ES_2011-09-20: Code generation for incremental evaluation
        (ASTNode.incremental ? jaddGenIncrementalTokenChange("value") : "") +
        //
        ind(2) + "token#TYPEINSIGNATURE#_#ID# = value;\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n"
        );
    if(decl.redefinesTokenComponent(this)) {
      buf.append(ind + "/**");
      buf.append(ind + " * @apilevel internal");
      buf.append(ind + " */");
      buf.append(ind + "protected #TYPE# #HOST#.token#TYPEINSIGNATURE#_#ID#;\n");
    }
    if(!isNTA()) {
      boolean isStringToken = getTokenId().getTYPE().equals("String") || getTokenId().getTYPE().equals("java.lang.String");
      if(isStringToken && ASTNode.beaver) {
        if(decl.redefinesTokenComponent(this)) {
          buf.append(
              ind + "public int #HOST#.#ID#start;\n" +
              ind + "public int #HOST#.#ID#end;\n"
              );
        }
        buf.append(
            ind + "public void #HOST#.set#ID#(beaver.Symbol symbol) {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            ind(2) + "if(symbol.value != null && !(symbol.value instanceof String))\n" +
            ind(3) + "throw new UnsupportedOperationException(\"set#ID# is only valid for String lexemes\");\n" +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenChange("symbol") : "") + 
            //
            ind(2) + "token#TYPEINSIGNATURE#_#ID# = (String)symbol.value;\n" +
            ind(2) + "#ID#start = symbol.getStart();\n" +
            ind(2) + "#ID#end = symbol.getEnd();\n" +
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n"
            );
      }
      if(isStringToken)
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenTrack() : "") +
            //
            ind(2) + "return token#TYPEINSIGNATURE#_#ID# != null ? token#TYPEINSIGNATURE#_#ID# : \"\";\n" +
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n");
      else
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenTrack() : "") +
            //
            ind(2) + "return token#TYPEINSIGNATURE#_#ID#;\n" +
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n");
    }
    String s = buf.toString();
    s = s.replaceAll("#ID#", getTokenId().getID());
    s = s.replaceAll("#TYPE#", getTokenId().getTYPE());
    s = s.replaceAll("#TYPEINSIGNATURE#", ASTNode.convTypeNameToSignature(getTokenId().getTYPE()));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);

  }


  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenHandler() {
    if (!isNTA()) {
    if (ASTNode.incrementalLevelParam)
      return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                 "new ASTNode$DepGraphNode(this, \"get#ID#\", null);\n";
    if (ASTNode.incrementalLevelAttr)
      return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                 "new ASTNode$DepGraphNode(this, \"get#ID#\");\n";
    }
    return ""; // ASTNode.incrementalLevelNode
  }
  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenChange(String varName) {
    StringBuffer buf = new StringBuffer();
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr || ASTNode.incrementalLevelNode) {
      buf.append("    if (!state().IN_CONSTRUCTION && !state().IN_REWRITE_EVAL && !state().IN_ATTR_STORE_EVAL) {\n");
    }
    if (ASTNode.incrementalLevelRegion) {
      buf.append("    if (!state().IN_CONSTRUCTION && !(state().IN_COMPUTATION > 0)) {\n");
    }
    if (isNTA()) {
      buf.append("     if (get#ID#_computed) {\n");
      buf.append("       get#ID#_computed = false;\n");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      buf.append("       get#ID#_handler.notifyDependencies();\n");
      }
      if (ASTNode.incrementalLevelNode) {
      buf.append("       handler.flushRegion();\n");
      }
      if (ASTNode.incrementalLevelRegion) {
      buf.append("       handler().flushRegion();\n");
      }
      buf.append("     }\n");
    } else {
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      buf.append("       get#ID#_handler.notifyDependencies();\n");
      }
      if (ASTNode.incrementalLevelNode) {
      buf.append("       handler.flushRegion();\n");
      }
      if (ASTNode.incrementalLevelRegion) {
      buf.append("       handler().flushRegion();\n");
      }
      buf.append("     ASTNode initial = inc_locateInitialCopy();\n");
      buf.append("     if (initial != null) {\n");
      buf.append("       state().enterConstruction();\n");
      buf.append("       ((#HOST#)initial).set#ID#(" + varName + ");\n");
      buf.append("       state().exitConstruction();\n");
      buf.append("       return;");
      buf.append("     }\n");
    }
    buf.append("    }\n");
    return buf.toString();
  }
  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenTrack() {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr)
      return "        state().addHandlerDepTo(get#ID#_handler);\n";
    if (ASTNode.incrementalLevelNode) {
      String type = getTokenId().getTYPE();
      boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
      boolean isPrimitiveToken = isPrimitive();
      if (!isStringToken && !isPrimitiveToken) {
        StringBuffer buf = new StringBuffer();
        buf.append("        if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode) {\n");
        buf.append("          state().addHandlerDepTo(((ASTNode)token#TYPEINSIGNATURE#_#ID#).handler);\n");
        buf.append("        }\n");
        return buf.toString();
      }
    }
    if (ASTNode.incrementalLevelRegion) {
      String type = getTokenId().getTYPE();
      boolean isStringToken = type.equals("String") || type.equals("java.lang.String");
      boolean isPrimitiveToken = isPrimitive();
      if (!isStringToken && !isPrimitiveToken) {
        StringBuffer buf = new StringBuffer();
        buf.append("        if (token#TYPEINSIGNATURE#_#ID# instanceof ASTNode && token#TYPEINSIGNATURE#_#ID#.isRegionRoot()) {\n");
        buf.append("          ((ASTNode)token#TYPEINSIGNATURE#_#ID#).handler().addDependant(handler());\n");
        buf.append("        }\n");
        return buf.toString();
      }
    }
    return "";
  }

  String AggregateComponents.setNameComment() {
    return ind + "/**\n" +
      ind + " * Setter for #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String AggregateComponents.getNameComment() {
    return ind + "/**\n" +
      ind + " * Getter for #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }

  public void AggregateComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate get-method for component
    s = setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "setChild(node, #INDEX#);\n" + 
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(!isNTA()) {
      s +=
        getNameComment() +
        ind + "public #TYPE# #HOST#.get#NAME#() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChild(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" + 
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#ChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }

  protected void Components.parse(String s) {
    jrag.AST.JragParser jp = new jrag.AST.JragParser(new java.io.StringReader(s));
    jp.root = hostClass().env();
    jp.setFileName(hostClass().getFileName());

    // EMMA_2011-09-08: Adding this to give .ast generated methods an enclosing 
    // aspect "Ast" which allows for refinement of these methods. For example,
    // "getA" generated from "B ::= A" can be refined using the "Ast" aspect.
    //jp.enclosingAspect = "Ast";

    try {
      while(true)
        jp.AspectBodyDeclaration();
    } catch (Exception e) {
    }
  }
}
