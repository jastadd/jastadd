import ast.AST.*;

import java.io.*;
import java.util.*;
import java.util.regex.*;

aspect JaddCodeGen {
  public void Grammar.abstractAncestors() {
    ASTDecl cl;
    IdDecl name;
    
    // Add ASTNode
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("ASTNode");
    cl.setIdDecl(name);
    cl.setFileName("");
    addTypeDecl(cl);
    
    // Add List
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("List");
    cl.setIdDecl(name);
    cl.setFileName("");
    addTypeDecl(cl);

    // Add Opt
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("Opt");
    cl.setIdDecl(name);
    cl.setFileName("");
    addTypeDecl(cl);
  }

  syn int ASTDecl.numNonNTAComponents() {
    int num = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        num++;
      }
    }
    return num;
  }

  /**
   * Number of children, including NTAs but excluding tokens
   */
  syn int ASTDecl.childCount() {
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!(c instanceof TokenComponent)) {
        i++;
      }
    }
    return i;
  }

  /**
   * Number of children, excluding NTAs and tokens
   */
  syn int ASTDecl.numRegularChildren() {
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && !(c instanceof TokenComponent)) {
        i++;
      }
    }
    return i;
  }

  /**
   * Emits the (nta) child initialization method
   */
  public void ASTDecl.emitChildInitMethod(PrintWriter out) {
    out.println(ind + "/**");
    out.println(ind + " * Initializes the child array to the correct size.");
    out.println(ind + " * Initializes List and Opt nta children.");
    out.println(ind + " * @apilevel internal");
    out.println(ind + " * @ast method");
    out.println(ind + " */");
    out.println(ind + "public void " + name() + ".init$Children() {");
    if (childCount() > 0) {
      out.println(ind(2) + "children = new ASTNode[" + childCount() + "];");
    }
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponents) {
        out.println(ind(2) + "setChild(new List(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof OptionalComponent) {
        out.println(ind(2) + "setChild(new Opt(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof AggregateComponents) {
        //stream.println(ind(2) + "setChild(null, " + String.valueOf(i) + ");");
        i++;
      }
    }
    out.println(ind + "}");
  }

  /**
   * Constructor to build trees bottom up
   */
  public void ASTDecl.emitBuildingConstructor(PrintWriter out) {
    // we only build constructors if there are components
    if(!getComponents().hasNext())
      return;
    out.print(ind + "public " + name() + "." + name() + "(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) out.print(", ");
        out.print(c.constrParmType() + " p" + i);
        i++;
      }
    }
    out.println(") {");
    if(ASTNode.block) out.print(ASTNode.blockBegin);
    // ES_2011-10-05: Code generation for incremental evaluation  
    if (ASTNode.incremental) out.print(genIncrementalConstructorStartConstruction());
    //
    int param = 0;
    int childIndex = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          String tokenId = t.getTokenId().getID();
          out.println(ind(2) + "set" + tokenId + "(p" + param + ");");
        }
        else {
          out.println(ind(2) + "setChild(p" + param + ", " + childIndex + ");");
          childIndex++;
        }
        param += 1;
      }
      else {
        if(c instanceof ListComponents) {
          out.println(ind(2) + "setChild(new List(), " + childIndex + ");");
          childIndex++;
        }
        else if(c instanceof OptionalComponent) {
          out.println(ind(2) + "setChild(new Opt(), " + childIndex + ");");
          childIndex++;
        }
        else if(c instanceof AggregateComponents) {
          out.println(ind(2) + "setChild(null, " + childIndex + ");");
          childIndex++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        out.println(ind(2) + "is$Final(java.lang.Integer.MAX_VALUE);");
      else {
        out.println(ind(2) + "is$Final(true);");
      }
    }
    // ES_2011-10-05: Code generation for incremental evaluation  
    if (ASTNode.incremental) out.print(genIncrementalConstructorEndConstruction());
    //
    // ES_2011-12-11: Code generation for incremental evaluation, track creation
    if (ASTNode.incremental) out.print(genIncrementalTrackCreation());
    //
    if(ASTNode.block) out.print(ASTNode.blockEnd);
    out.println(ind + "}");
  }

  public String ASTDecl.buildingSymbolConstructor() {
    // we only build constructors if there are components ...
    if(!getComponents().hasNext())
      return "";
    // ... and one of these components is a string token component
    boolean stringArg = false;
    for(Iterator iter = getComponents(); !stringArg && iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
        stringArg = true;
    }
    if(!stringArg) return "";

    StringBuffer s = new StringBuffer();
    s.append(ind + "public #ID#.#ID#(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) s.append(", ");
        if(c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
          s.append("beaver.Symbol p" + i);
        else
          s.append(c.constrParmType() + " p" + i);
        i++;
      }
    }
    s.append(") {\n");
    if(ASTNode.block) s.append(ASTNode.blockBegin);
    // ES_2011-10-05: Code generation for incremental evaluation, construction 
    if (ASTNode.incremental) s.append(genIncrementalConstructorStartConstruction());
    //
    i = 0;
    int j = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          s.append(ind(2) + "set" + t.getTokenId().getID() + "(p" + i + ");\n");
        }
        else {
          s.append(ind(2) + "setChild(p" + String.valueOf(i) + ", " + j + ");\n");
          j++;
        }
        i++;
      }
      else {
        if(c instanceof ListComponents) {
          s.append(ind(2) + "setChild(new List(), " + j + ");\n");
          j++;
        }
        else if(c instanceof OptionalComponent) {
          s.append(ind(2) + "setChild(new Opt(), " + j + ");\n");
          j++;
        }
        else if(c instanceof AggregateComponents) {
          s.append(ind(2) + "setChild(null, " + j + ");\n");
          j++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        s.append(ind(2) + "is$Final(java.lang.Integer.MAX_VALUE);\n");
      else {
        s.append(ind(2) + "is$Final(true);\n");
      }
    }
    // ES_2011-10-05: Code generation for incremental evaluation, construction
    if (ASTNode.incremental) s.append(genIncrementalConstructorEndConstruction());
    //
    // ES_2011-12-11: Code generation for incremental evaluation, track creation
    if (ASTNode.incremental) s.append(genIncrementalTrackCreation());
    //
    if(ASTNode.block) s.append(ASTNode.blockEnd);
    s.append(ind + "}\n");
    return s.toString().replaceAll("#ID#", name());
  }

  public void Grammar.genReset(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode$State.reset() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(circularEnabled) {
      stream.println(ind(2) + "IN_CIRCLE = false;");
      stream.println(ind(2) + "CIRCLE_INDEX = 1;"); // TOBBE
      stream.println(ind(2) + "CHANGE = false;");
      if(cacheCycle)
          stream.println(ind(2) + "LAST_CYCLE = false;");
      if(componentCheck) {
          stream.println(ind(2) + "circularEvalSet = " + ASTNode.createDefaultSet + ";");
          stream.println(ind(2) + "circularEvalStack = new java.util.Stack();");
      }
    }
    if(rewriteEnabled) {
      stream.println(ind(2) + "boundariesCrossed = 0;");
      genResetDuringCounters(stream);
      if(rewriteLimit > 0)
        stream.println(ind(2) + "debugRewrite = " + ASTNode.createDefaultMap + ";\n");
      if(stagedRewrites)
        stream.println(ind(2) + "rewritePhase = 1;\n");
    }
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
  }

  public void Grammar.jjtGenASTNode$State(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println("/**");
    stream.println(" * @apilevel internal");
    stream.println(" */");
    stream.println("static public class ASTNode$State {");
    if(circularEnabled) {
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean IN_CIRCLE = false;");
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public int CIRCLE_INDEX = 1;");
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean CHANGE = false;");
      if(cacheCycle) {
        stream.println("/**");
        stream.println(" * @apilevel internal");
        stream.println(" */");
        stream.println(ind + "public boolean LAST_CYCLE = false;");
      }
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean RESET_CYCLE = false;");

      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static public class CircularValue {");
      stream.println(ind(2) + "Object value;");
      stream.println(ind(2) + "int visited = -1;");
      stream.println(ind + "}");

      if(componentCheck) {
        stream.println(ind + "public " + ASTNode.typeDefaultSet + " circularEvalSet = " + ASTNode.createDefaultSet + ";");
        stream.println(ind + "public java.util.Stack circularEvalStack = new java.util.Stack();");

        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "static class CircularEvalEntry {");
        stream.println(ind(2) + "ASTNode node;");
        stream.println(ind(2) + "String attrName;");
        stream.println(ind(2) + "Object parameters;");

        stream.println(ind(2) + "public CircularEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(3) + "this.node = node;");
        stream.println(ind(3) + "this.attrName = attrName;");
        stream.println(ind(3) + "this.parameters = parameters;");
        stream.println(ind(2) + "}");

        stream.println(ind(2) + "public boolean equals(Object rhs) {");
        stream.println(ind(3) + "CircularEvalEntry s = (CircularEvalEntry) rhs;");
        stream.println(ind(3) + "if (parameters == null && s.parameters == null)");
        stream.println(ind(4) + "return node == s.node && attrName.equals(s.attrName);");
        stream.println(ind(3) + "else if (parameters != null && s.parameters != null)");
        stream.println(ind(4) + "return node == s.node && attrName.equals(s.attrName) && parameters.equals(s.parameters);");
        stream.println(ind(3) + "else");
        stream.println(ind(4) + "return false;");
        stream.println(ind(2) + "}");

        stream.println(ind(2) + "public int hashCode() {");
        stream.println(ind(3) + "return node.hashCode();");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");

        stream.println(ind + "public void addEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(2) + "circularEvalSet.add(new CircularEvalEntry(node,attrName,parameters));");
        stream.println(ind + "}");

        stream.println(ind + "public boolean containsEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(2) + "return circularEvalSet.contains(new CircularEvalEntry(node,attrName,parameters));");
        stream.println(ind + "}");

        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "static class CircularStackEntry {");
        stream.println(ind(2) + "" + ASTNode.typeDefaultSet + " circularEvalSet;");
        stream.println(ind(2) + "boolean changeValue;");

        stream.println(ind(2) + "public CircularStackEntry(" + ASTNode.typeDefaultSet + " set, boolean change) {");
        stream.println(ind(3) + "circularEvalSet = set;");
        stream.println(ind(3) + "changeValue = change;");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");

        stream.println(ind + "public void pushEvalStack() {");
        stream.println(ind(2) + "circularEvalStack.push(new CircularStackEntry(circularEvalSet, CHANGE));");
        stream.println(ind(2) + "circularEvalSet = " + ASTNode.createDefaultSet + ";");
        stream.println(ind(2) + "CHANGE = false;");
        stream.println(ind + "}");

        stream.println(ind + "public void popEvalStack() {");
        stream.println(ind(2) + "CircularStackEntry c = (CircularStackEntry) circularEvalStack.pop();");
        stream.println(ind(2) + "circularEvalSet = c.circularEvalSet;");
        stream.println(ind(2) + "CHANGE = c.changeValue;");
        stream.println(ind + "}");

      }
    }
    if(rewriteEnabled) {
      stream.println(ind + "public static final int REWRITE_CHANGE = 1;");
      stream.println(ind + "public static final int REWRITE_NOCHANGE = 2;");
      stream.println(ind + "public static final int REWRITE_INTERRUPT = 3;");
      if(rewriteLimit > 0) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public java.util.HashMap debugRewrite = " + ASTNode.createDefaultMap + ";\n");
      }
      stream.println(ind + "public int boundariesCrossed = 0;\n");
      if(stagedRewrites)
        stream.println(ind + "public int rewritePhase = 1;");
      // state code
      stream.println(ind + "private int[] stack;");
      stream.println(ind + "private int pos;");
      stream.println(ind + "public ASTNode$State() {");
      stream.println(ind(3) + "stack = new int[64];");
      stream.println(ind(3) + "pos = 0;");
      stream.println(ind + "}");
      stream.println(ind + "private void ensureSize(int size) {");
      stream.println(ind(3) + "if(size < stack.length)");
      stream.println(ind(4) + "return;");
      stream.println(ind(3) + "int[] newStack = new int[stack.length * 2];");
      stream.println(ind(3) + "System.arraycopy(stack, 0, newStack, 0, stack.length);");
      stream.println(ind(3) + "stack = newStack;");
      stream.println(ind + "}");
      stream.println(ind + "public void push(int i) {");
      stream.println(ind(2) + "ensureSize(pos+1);");
      stream.println(ind(2) + "stack[pos++] = i;");
      stream.println(ind + "}");
      stream.println(ind + "public int pop() {");
      stream.println(ind(2) + "return stack[--pos];");
      stream.println(ind + "}");
      stream.println(ind + "public int peek() {");
      stream.println(ind(2) + "return stack[pos-1];");
      stream.println(ind + "}");
    }

    if(j2me) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class HashtableBasedSet  {");
      stream.println(ind(2) + "public HashtableBasedSet(int initialCapacity) {");
      stream.println(ind(3) + "map = new java.util.Hashtable(initialCapacity);");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "private java.util.Hashtable map;");
      stream.println(ind(2) + "private static final Object PRESENT = new Object();");
      stream.println(ind(2) + "public java.util.Enumeration elements() { return map.keys(); }");
      stream.println(ind(2) + "public int size() { return map.size(); }");
      stream.println(ind(2) + "public boolean isEmpty() { return map.isEmpty(); }");
      stream.println(ind(2) + "public boolean contains(Object o) { return map.containsKey(o); }");
      stream.println(ind(2) + "public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
      stream.println(ind(2) + "public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
      stream.println(ind(2) + "public void clear() { map.clear(); }");
      stream.println(ind + "}");
    }
    else if(deterministic) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class IdentityHashSet extends java.util.LinkedHashSet {");
      stream.println(ind(2) + "public IdentityHashSet(int initialCapacity) { super(initialCapacity); }");
      stream.println(ind(2) + "/**");
      stream.println(ind(2) + " * @apilevel internal");
      stream.println(ind(2) + " */");
      stream.println(ind(2) + "public java.util.Iterator iterator() {");
      stream.println(ind(3) + "final java.util.Iterator i = super.iterator();");
      stream.println(ind(3) + "return new java.util.Iterator() {");
      stream.println(ind(4) + "public boolean hasNext() { return i.hasNext(); }");
      stream.println(ind(4) + "public Object next() { return ((Wrapper)i.next()).o; }");
      stream.println(ind(4) + "public void remove() { i.remove(); }");
      stream.println(ind(3) + "};");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "public boolean contains(Object o) { return super.contains(wrap(o)); }");
      stream.println(ind(2) + "public boolean add(Object o) { return super.add(wrap(o)); }");
      stream.println(ind(2) + "public boolean remove(Object o) { return super.remove(wrap(o)); }");
      stream.println(ind(2) + "private Wrapper wrap(Object o) { return new Wrapper(o); }");
      stream.println(ind(2) + "/**");
      stream.println(ind(2) + " * @apilevel internal");
      stream.println(ind(2) + " */");
      stream.println(ind(2) + "private static class Wrapper {");
      stream.println(ind(3) + "private Object o;");
      stream.println(ind(3) + "private Wrapper(Object o) { this.o = o; }");
      stream.println(ind(3) + "public boolean equals(Object other) { return other instanceof Wrapper && ((Wrapper)other).o == o; }");
      stream.println(ind(3) + "public int hashCode() { return System.identityHashCode(o); }");
      stream.println(ind(2) + "}");
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class IdentityHashSet extends java.util.AbstractSet implements java.util.Set {");
      stream.println(ind(2) + "public IdentityHashSet(int initialCapacity) {");
      stream.println(ind(3) + "map = new java.util.IdentityHashMap(initialCapacity);");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "private java.util.IdentityHashMap map;");
      stream.println(ind(2) + "private static final Object PRESENT = new Object();");
      stream.println(ind(2) + "public java.util.Iterator iterator() { return map.keySet().iterator(); }");
      stream.println(ind(2) + "public int size() { return map.size(); }");
      stream.println(ind(2) + "public boolean isEmpty() { return map.isEmpty(); }");
      stream.println(ind(2) + "public boolean contains(Object o) { return map.containsKey(o); }");
      stream.println(ind(2) + "public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
      stream.println(ind(2) + "public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
      stream.println(ind(2) + "public void clear() { map.clear(); }");
      stream.println(ind + "}");
    }

    // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
    if (ASTNode.incremental) jjtGenIncrementalEvaluationStack(stream);

    stream.println("}"); // End ASTNode$State
  }

  /**
   * The minimum list size (above zero)
   */
  private static final int ASTDecl.MIN_LIST_LIMIT = 4;

  /**
   * Print the getChild method to the output stream.
   */
  public void ASTDecl.genGetChild(PrintWriter stream, boolean rewriteEnabled) {
    String returnTypeCast;
    if(ASTNode.java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "@SuppressWarnings(\"cast\") public T ASTNode.getChild(int i) {");
      returnTypeCast = "(T) ";
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public ASTNode ASTNode.getChild(int i) {");
      returnTypeCast = "";
    }

    if(rewriteEnabled) {
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      stream.println(ind(2) + "ASTNode node = this.getChildNoTransform(i);");
      stream.println(ind(2) + "if(node == null) return null;");
      stream.println(ind(2) + "if(node.is$Final()) {");
      // ES_2011-10-05: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) {
        jjtGenIncrementalTrackRewrite4(stream);
        genIncrementalTrackRewrite12(stream);
      }
      //
      stream.println(ind(3) +   "return " + returnTypeCast + "node;");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "if(!node.mayHaveRewrite()) {");
      if(ASTNode.stagedRewrites)
        stream.println(ind(3) + "node.is$Final(this.is$Final);");
      else
        stream.println(ind(3) + "node.is$Final(this.is$Final());");
      // ES_2011-10-05: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) {
        jjtGenIncrementalTrackRewrite4(stream);
        genIncrementalTrackRewrite12(stream);
      }
      //
      stream.println(ind(3) + "return " + returnTypeCast + "node;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if(!node.in$Circle()) {");
      // ES_2011-09-26: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite1(stream);
      //
      // ES_2011-10-10: Code generation for full flush
      if (ASTNode.fullFlush) jjtGenFullFlush1(stream);
      //
      stream.println(ind(3) + "int rewriteState;");
      stream.println(ind(3) + "int num = this.state().boundariesCrossed;");
      stream.println(ind(3) + "do {");
      stream.println(ind(4) + "this.state().push(ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(4) + "ASTNode oldNode = node;");
      stream.println(ind(4) + "oldNode.in$Circle(true);");
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite5(stream);
      //
      stream.println(ind(4) + "node = node.rewriteTo();");
      stream.println(ind(4) + "if(node != oldNode) {");
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite7(stream);
      //
      stream.println(ind(5) + "this.setChild(node, i);");
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite8(stream);
      //
      stream.println(ind(4) + "}");
      stream.println(ind(4) + "oldNode.in$Circle(false);");
      stream.println(ind(4) + "rewriteState = this.state().pop();");
      // ES_2011-09-30: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite3(stream);
      //
      // ES_2011-10-10: Code generation for full flush
      if (ASTNode.fullFlush) jjtGenFullFlush2(stream);
      //
      // ES_2011-12-10: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite6(stream);
      //
      stream.println(ind(3) + "} while(rewriteState == ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(3) + "if(rewriteState == ASTNode$State.REWRITE_NOCHANGE && this.is$Final()) {");
      if(ASTNode.stagedRewrites)
        stream.println(ind(4) + "node.is$Final(this.state().rewritePhase);");
      else
        stream.println(ind(4) + "node.is$Final(true);");
      stream.println(ind(4) + "this.state().boundariesCrossed = num;");
      if(rewriteLimit > 0)
        stream.println(ind(4) + "node.debugRewriteRemove();");
      stream.println(ind(3) + "}");
      // ES_2011-09-30: Code generation for incremental evaluation, rewrites
      if (ASTNode.incremental) jjtGenIncrementalTrackRewrite2(stream);
      //
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "else if(this.is$Final() != node.is$Final()) this.state().boundariesCrossed++;");
      // ES_2011-12-12: Code generation for incremental evaluation, rewrites 
      if (ASTNode.incremental) {
        jjtGenIncrementalTrackRewrite11(stream);
        genIncrementalTrackRewrite12(stream);
      }
      //
      stream.println(ind(2) + "return " + returnTypeCast + "node;");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
    } else {
      // No rewrites
      stream.println(ind(2) + "ASTNode child = getChildNoTransform(i);");
      // ES_2011-09-20: Code generation for incremental evaluation
      if (ASTNode.incremental) {
        jjtGenIncrementalTrackGetChildNoTransform(stream);
      }
      //
      stream.println(ind(2) + "return " + returnTypeCast + "child;");
    }

    stream.println(ind + "}");
  }

  public void ASTDecl.jjtGenASTNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithCircularEnabled = " + ASTNode.circularEnabled + ";");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithCacheCycle = " + ASTNode.cacheCycle + ";");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithComponentCheck = " + ASTNode.componentCheck + ";");
    if(ASTNode.noStatic) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode$State ASTNode.state = null;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode$State ASTNode.state() {");
      stream.println(ind(2) + "if(state == null) {");
      stream.println(ind(3) + "if(parent == null) {");
      stream.println(ind(4) + "state = new ASTNode$State();");
      if(ASTNode.debugMode) {
        // Debug mode should (probably) not be used here to ensure safe use of the state field
        //  Jesper 2013-01-10

        // Check if a new state object is created for a node that is not a root node
        StringBuffer s = new StringBuffer();
        s.append("if(");
        boolean first = true;
        for(Iterator iter = env().roots().iterator(); iter.hasNext(); ) {
          ASTDecl root = (ASTDecl)iter.next();
          if(!first)
            s.append(" && ");
          first = false;
          s.append("!(this instanceof " + root.name() + ")");
        }
        s.append(") throw new RuntimeException(\"Trying to evaluate state in a node which is not attached to the main tree\");");
        stream.println(s.toString());
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "else {");
      stream.println(ind(4) + "state = parent.state();");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return state;");
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected static ASTNode$State ASTNode.state = new ASTNode$State();");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode$State ASTNode.state() { return state; }");
    }

    if(rewriteEnabled) {
      if(rewriteLimit > 0) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.debugRewrite(String info) {");
        stream.println(ind(2) + "if(!parent.is$Final()) return;");
        stream.println(ind(2) + "java.util.ArrayList key = new java.util.ArrayList(2);");
        stream.println(ind(2) + "key.add(getParent());");
        stream.println(ind(2) + "key.add(new Integer(getParent().getIndexOfChild(this)));");
        stream.println(ind(2) + "java.util.ArrayList list;");
        stream.println(ind(2) + "if(state().debugRewrite.containsKey(key))");
        stream.println(ind(3) + "list = (java.util.ArrayList)state().debugRewrite.get(key);");
        stream.println(ind(2) + "else {");
        stream.println(ind(3) + "list = new java.util.ArrayList();");
        stream.println(ind(3) + "state().debugRewrite.put(key, list);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "list.add(info);");
        stream.println(ind(2) + "if(list.size() > " + rewriteLimit + ") {");
        stream.println(ind(3) + "StringBuffer buf = new StringBuffer(\"Iteration count exceeded for rewrite:\");");
        stream.println(ind(3) + "for(java.util.Iterator iter = list.iterator(); iter.hasNext(); ) buf.append(\"\\n\" + iter.next());");
        stream.println(ind(3) + "throw new RuntimeException(buf.toString());");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.debugRewriteRemove() {");
        stream.println(ind(2) + "java.util.ArrayList key = new java.util.ArrayList(2);");
        stream.println(ind(2) + "key.add(getParent());");
        stream.println(ind(2) + "key.add(new Integer(getParent().getIndexOfChild(this)));");
        stream.println(ind(2) + "state().debugRewrite.remove(key);");
        stream.println(ind + "}\n");
      }
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean ASTNode.in$Circle = false;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean ASTNode.in$Circle() { return in$Circle; }");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.in$Circle(boolean b) { in$Circle = b; }");
      if(ASTNode.stagedRewrites) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public int ASTNode.is$Final = 0;");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final() { return is$Final >= state().rewritePhase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.is$Final(int phase) { is$Final = phase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.enterRewritePhase(int phase) { state().rewritePhase = phase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.inRewritePhase(int phase) { return state().rewritePhase >= phase; }");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final = false;");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final() { return is$Final; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.is$Final(boolean b) { is$Final = b; }");
      }
    }

    genGetChild(stream, rewriteEnabled);

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "private int ASTNode.childIndex;");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public int ASTNode.getIndexOfChild(ASTNode node) {");

    // ES_2011_12_17: Code generation for incremental evaluation
    if (ASTNode.incremental) {
      stream.println(ind(2) + "if(node != null && node.childIndex < numChildren && node == children[node.childIndex])");
      stream.println(ind(3) + "return node.childIndex;");
      stream.println(ind(2) + "for(int i = 0; children != null && i < children.length; i++)");
      stream.println(ind(3) + "if(children[i] == node) {");
      stream.println(ind(4) + "node.childIndex = i;");
      stream.println(ind(4) + "return i;");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "return -1;");
    } else {
      stream.println(ind(2) + "if(node != null && node.childIndex < getNumChildNoTransform() && node == getChildNoTransform(node.childIndex))");
      stream.println(ind(3) + "return node.childIndex;");
      stream.println(ind(2) + "for(int i = 0; i < getNumChildNoTransform(); i++)");
      stream.println(ind(3) + "if(getChildNoTransform(i) == node) {");
      stream.println(ind(4) + "node.childIndex = i;");
      stream.println(ind(4) + "return i;");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "return -1;");
    }
    //
    stream.println(ind + "}\n");
    if(ASTNode.java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.addChild(T node) {");
    } else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.addChild(ASTNode node) {");
    }
    stream.println(ind(2) + "setChild(node, getNumChildNoTransform());");
    // ES_2012-01-31: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncrementalASTChangeAddChild1(stream); 
    //
    stream.println(ind + "}");


    if(ASTNode.java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * <p><em>This method does not invoke AST transformations.</em></p>");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "@SuppressWarnings(\"cast\")");
      // ES_2011-12-13: Code generation for incremental evaluation    
      if (ASTNode.incremental) jjtGenIncrementalTrackGetChildNoTransformName2(stream);
      else 
      //
      stream.println(ind + "public final T ASTNode.getChildNoTransform(int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      // ES_2011-09-20: Code generation for incremental evaluation
      if (ASTNode.incremental) {
        stream.println(ind(2) + "T child = (T)children[i];");
        jjtGenIncrementalTrackGetChildNoTransform(stream);
        stream.println(ind(2) + "return child;");        
      } else 
      //
      stream.println(ind(2) + "return (T)children[i];");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * <p><em>This method does not invoke AST transformations.</em></p>");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      // ES_2011-12-13: Code generation for incremental evaluation    
      if (ASTNode.incremental) jjtGenIncrementalTrackGetChildNoTransformName1(stream);
      else 
      //
      stream.println(ind + "public final ASTNode ASTNode.getChildNoTransform(int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      // ES_2011-09-20: Code generation for incremental evaluation
      if (ASTNode.incremental) {
        stream.println(ind(2) + "ASTNode child = (ASTNode)children[i];");
        jjtGenIncrementalTrackGetChildNoTransform(stream);
        stream.println(ind(2) + "return child;");        
      } else 
      //
      stream.println(ind(2) + "return (ASTNode)children[i];");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren;"); // added
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren() {");
    // ES_2011-09-20: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
    stream.println(ind(2) + "return numChildren;");
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public int ASTNode.getNumChild() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    // ES_2011-09-20: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
    stream.println(ind(2) + "return numChildren();");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * <p><em>This method does not invoke AST transformations.</em></p>");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public final int ASTNode.getNumChildNoTransform() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    stream.println(ind(2) + "return numChildren();");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.setChild(ASTNode node, int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(debugMode)
      stream.println(ind(2) + "debugNodeAttachment(node);");
    // ES_2011-10-06: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild1(stream);
    //
    stream.println(ind(2) + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[i+1>" + MIN_LIST_LIMIT + "?i+1:" + MIN_LIST_LIMIT + "];");
    // ES_2011-10-06: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild2(stream);
    //
    stream.println(ind(2) + "} else if (i >= children.length) {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[i << 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, children.length);");
    stream.println(ind(3) + "children = c;");
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild3(stream);
    //
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.fullFlush) jjtGenFullFlushSetChild1(stream);
    //
    stream.println(ind(2) + "}");
    // ES_2011-11-28: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild5(stream);
    //
    stream.println(ind(2) + "children[i] = node;");
    stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild4(stream);
    //
    // ES_2011-09-20: Code generation for incremental evaluation, set child
    if (ASTNode.fullFlush) jjtGenFullFlushSetChild2(stream);
    //
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.insertChild(ASTNode node, int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(debugMode)
      stream.println(ind(2) + "debugNodeAttachment(node);");
    // ES_2011-10-06: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild3(stream);
    //
    stream.println(ind(2) + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[i+1>" + MIN_LIST_LIMIT + "?i+1:" + MIN_LIST_LIMIT + "];");
    stream.println(ind(3) + "children[i] = node;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild1(stream);
    //
    stream.println(ind(2) + "} else {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[children.length + 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, i);");
    stream.println(ind(3) + "c[i] = node;");
    stream.println(ind(3) + "if(i < children.length) {");
    stream.println(ind(4) + "System.arraycopy(children, i, c, i+1, children.length-i);");
    stream.println(ind(4) + "for(int j = i+1; j < c.length; ++j) {");
    stream.println(ind(5) +   "if(c[j] != null)");
    stream.println(ind(6) +     "c[j].childIndex = j;");
    stream.println(ind(4) +   "}");
    stream.println(ind(3) + "}");
    stream.println(ind(3) + "children = c;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild2(stream);
    //
    // ES_2011-10-10: Code generation for full flush
    if (ASTNode.fullFlush) jjtGenFullFlushInsertChild1(stream);
    //
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "numChildren++;");
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.removeChild(int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    stream.println(ind(2) + "if(children != null) {");
    // ES_2011-10-06: Code generation for incremental evaluation, remove child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeRemoveChild1(stream);
    //
    stream.println(ind(3) + "ASTNode child = (ASTNode)children[i];");
    stream.println(ind(3) + "if(child != null) {");
    // ES_2011-11-28: Code generation for incremental evaluation, remove child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeRemoveChild3(stream);
    // 
    stream.println(ind(4) + "child.parent = null;");
    stream.println(ind(4) + "child.childIndex = -1;");
    stream.println(ind(3) + "}");
    // ES_2012-03-01: Adding a check of this instance to make sure its a List, a move of children doesn't make
    // any sense for a node unless its a list. Also, there is a problem if a child of a non-List node is removed
    // and siblings are moved one step to the right, with null at the end.
    stream.println(ind(3) + "if (this instanceof List || this instanceof Opt) {");
    stream.println(ind(4) +   "System.arraycopy(children, i+1, children, i, children.length-i-1);");
    stream.println(ind(4) +   "children[children.length-1] = null;");
    stream.println(ind(4) +   "numChildren--;");
    // fix child indices
    stream.println(ind(4) +   "for(int j = i; j < numChildren; ++j) {");
    stream.println(ind(5) +     "if(children[j] != null) {");
    stream.println(ind(6) +       "child = (ASTNode) children[j];");
    stream.println(ind(6) +       "child.childIndex = j;");
    stream.println(ind(5) +     "}");
    stream.println(ind(4) +   "}");
    stream.println(ind(3) + "} else {");
    stream.println(ind(4) +   "children[i] = null;");
    stream.println(ind(3) + "}");
    // ES_2011-10-06: Code generation for incremental evaluation, remove child
    if (ASTNode.incremental) jjtGenIncrementalASTChangeRemoveChild2(stream);
    //
    // ES_2011-10-06: Code generation for full flush, remove child
    if (ASTNode.fullFlush) jjtGenFullFlushRemoveChild1(stream);
    //
    stream.println(ind(2) + "}");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public ASTNode ASTNode.getParent() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(rewriteEnabled) {
      stream.println(ind(2) + "if(parent != null && ((ASTNode)parent).is$Final() != is$Final()) {");
      stream.println(ind(3) + "state().boundariesCrossed++;");
      stream.println(ind(2) + "}");
    }
    // ES_2011-09-20: Code generation for incremental evaluation, track getParent
    if (ASTNode.incremental) jjtGenIncrementalTrackGetParent(stream);
    //
    stream.println(ind(2) + "return (ASTNode)parent;");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.setParent(ASTNode node) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    // ES_2011-10-10: Code generation for incremental evaluation, set parent
    if (ASTNode.incremental) jjtGenIncrementalSetParent(stream);
    //
    stream.println(ind(2) + "parent = node;");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    if(!jjtree) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode ASTNode.parent;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode[] ASTNode.children;");
    }
    if(debugMode) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected boolean ASTNode.debugNodeAttachmentIsRoot() { return false; }");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "private static void ASTNode.debugNodeAttachment(ASTNode node) {");
      stream.println(ind(2) + "if(node == null) throw new RuntimeException(\"Trying to assign null to a tree child node\");");
      stream.println(ind(2) + "while(node != null && !node.debugNodeAttachmentIsRoot()) {");
      if(rewriteEnabled)
        stream.println(ind(3) + "if(node.in$Circle()) return;");
      stream.println(ind(3) + "ASTNode parent = (ASTNode)node.parent;");
      stream.println(ind(3) + "if(parent != null && parent.getIndexOfChild(node) == -1) return;");
      stream.println(ind(3) + "node = parent;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if(node == null) return;");
      stream.println(ind(2) + "throw new RuntimeException(\"Trying to insert the same tree at multiple tree locations\");");
      stream.println(ind + "}");
    }
  }

  public void ASTDecl.jjtGenFlushCache(PrintWriter stream) {

    // ES_2011-10-10: Checking full flush flag
    if (ASTNode.fullFlush) {

      if (name().equals("ASTNode")) {
        // ES_TODO: These should be protected, public now for debugging reasons
        stream.println(ind + "public ASTNode[] init_children;");
        stream.println(ind + "public boolean[] rewritten_children;");
        stream.println(ind + "protected boolean inc_hasEnclosingRewrittenNode() {");
        stream.println(ind(2) + "ASTNode child = this;");
        stream.println(ind(2) + "ASTNode parent = this.parent;");
        stream.println(ind(2) + "while (parent != null) {");
        //stream.println(ind(3) +   "int index = parent.getIndexOfChild(child);");
        stream.println(ind(3) +   "if (parent.mayHaveRewrite()) {");
        //stream.println(ind(3) +   "if (parent.rewritten_children != null && parent.rewritten_children[index]) {");
        stream.println(ind(4) +     "return true;");
        stream.println(ind(3) +   "}");
        stream.println(ind(3) +   "child = parent;");
        stream.println(ind(3) +   "parent = parent.parent;");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "return false;");
        stream.println(ind + "}");
      }
    }
    //if (name().equals("List")) {
    //  stream.println(ind + "public boolean is$Final() { return super.is$Final() && !list$touched; }");
    //}

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.print(ind + "public void flushCache() {\n");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);

    if (ASTNode.fullFlush) {
      if(!name().equals("ASTNode"))
        stream.print(ind(2) + "super.flushCache();\n");
      else {
        // flush rewrite or traverse to child
        stream.println(ind(3) + "for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println(ind(4) +   "if (rewritten_children != null && rewritten_children[i]) {");
        stream.println(ind(5) +     "if (init_children[i] != null) {");
        stream.println(ind(6) +       "setChild(init_children[i], i);");
        stream.println(ind(6) +       "init_children[i] = null;");
        stream.println(ind(5) +     "}");
        stream.println(ind(5) +     "rewritten_children[i] = false;");
        stream.println(ind(4) +   "} else {");
        stream.println(ind(5) +     "getChildNoTransform(i).flushCache();");
        stream.println(ind(4) +   "}");
        stream.println(ind(3) + "}");
      }
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrEq equ = getSynEq(k);
        AttrDecl attr = equ.decl();
        String u = attr.resetVisit() + attr.resetCache();
        u = u.replaceAll("#NAME#", attr.attributeSignature());
        stream.print(u);
        //if (ASTNode.incrementalTrack) {
        //  stream.println(ind(2) + "ASTNode$DepGraphNode.trackedFlushes++;");
        //}
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        String u = attr.resetVisit() + attr.resetCache();
        u = u.replaceAll("#NAME#", attr.attributeSignature());
        stream.print(u);
        //if (ASTNode.incrementalTrack) {
        //  stream.println(ind(2) + "ASTNode$DepGraphNode.trackedFlushes++;");
        //}
      }

      // tokens
      for (int c = 0; c < getNumComponents(); c++) {
    	  Components comp = getComponents(c);
     	  if (comp instanceof TokenComponent) {
          String type = ASTNode.convTypeNameToSignature(((TokenComponent)comp).getTokenId().getTYPE());
          boolean isStringToken = ((TokenComponent)comp).getTokenId().getTYPE().equals("String") || 
            ((TokenComponent)comp).getTokenId().getTYPE().equals("java.lang.String");
          if (!isStringToken) {
  	   	    stream.println(ind(2) + "if (token" + type + "_" + ((TokenComponent)comp).getTokenId().getID() + " instanceof ASTNode) {");
	     		  stream.println(ind(3) +   "token" + type + "_" + ((TokenComponent)comp).getTokenId().getID() + " = null;");
	     			stream.println(ind(2) + "}");
          }
    		}
    	}
  
      stream.print(flushCollectionCacheString());
    }

    if(ASTNode.block) stream.print(ASTNode.blockEnd);

    stream.print(ind + "}\n");

    if (ASTNode.fullFlush) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.print(ind + "public void flushCollectionCache() {\n");
      if(!name().equals("ASTNode"))
        stream.print(ind(2) + "super.flushCollectionCache();\n");
      stream.print(flushCollectionCacheString());
      stream.print(ind + "}\n");
    }
  }

  public void ASTDecl.jjtGenCheckTreeStructure(PrintWriter stream) {
    stream.println(ind + "public void " + name() + ".jjtAddChild(Node n, int i) {");
    stream.println(ind(2) + "checkChild(n, i);");
    if(name().equals("ASTNode")) {
      stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    }
    stream.println(ind(2) + "super.jjtAddChild(n, i);");
    stream.println("}\n");
    if(name().equals("Opt")) {
      stream.println(ind + "public void Opt.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(i > 0) throw new Error(\"Optional nodes can only have one child\");");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"Node type must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else if(name().equals("List")) {
      stream.println(ind + "public void List.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"The node type of child \" + i + \" must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else {
      int j = 0;
      stream.println(ind + "public void " + name() + ".checkChild(Node n, int i) {");
      for(Iterator iter = getComponents(); iter.hasNext(); ) {
        Components c = (Components)iter.next();
        c.jjtGenCheckTreeStructure(stream, j);
        if(!(c instanceof TokenComponent)) {
          j++;
        }
      }
      stream.println(ind + "}\n");
    }
  }

  public void Components.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
  }

  public void ListComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + ") {");
    stream.println(
        ind(3) + "if(!(n instanceof List))\n" + 
        ind(4) + "throw new Error(\"Child number " + j + " of " + hostClass().name() + 
        " has the type \" + n.getClass().getName() + \" which is not an instance of List\");");
    stream.println(ind(3) + "for(int k = 0; k < ((List)n).getNumChildNoTransform(); k++)");
    stream.println(
        ind(3) + "if(!(((List)n).getChildNoTransform(k) instanceof " + type() + "))\n" + 
        ind(4) + "throw new Error(\"Child number \" + k + \" in " + name() + "List" + 
        " has the type \" + ((List)n).getChildNoTransform(k).getClass().getName() + \" which is not an instance of " +
        type() + "\");");
    stream.println(ind(2) + "}");
  }

  public void OptionalComponent.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + ") {");
    stream.println(
        ind(3) + "if(!(n instanceof Opt))\n" + 
        ind(4) + "throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of Opt\");");
    stream.println(
        ind(3) + "if(((Opt)n).getNumChildNoTransform() != 0 && !(((Opt)n).getChildNoTransform(0) instanceof " + type() + "))\n" +
        ind(4) + "throw new Error(\"Optional " + name() + 
        " has the type \" + ((Opt)n).getChildNoTransform(0).getClass().getName() + \" which is not an instance of " +
        type() + "\");");
    stream.println(ind(2) + "}");
  }

  public void AggregateComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + " && !(n instanceof " + type() + ")) " + 
        " throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of " + type() + "\");");
  }

  public void ASTDecl.jjtGenDumpTree(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    StringBuffer sb = new StringBuffer();
    sb.append(ind + "public void " + name() + ".dumpTree(String indent, java.io.PrintStream pStream) {\n" + 
        ind(2) + "pStream.println(indent + \"" + name() + "\"");
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof TokenComponent) {
        TokenComponent t = (TokenComponent)c;
        String id = t.getTokenId().getID();
        sb.append("+ \"\\\"\" + get" + id + "() + \"\\\"\"");
      }
    }
    sb.append(");\n        String childIndent = indent + \"  \";\n" + 
        ind(2) + "for(int i = 0; i < getNumChild(); i++)\n" + 
        ind(3) + "getChild(i).dumpTree(childIndent, pStream);\n" +
        ind + "}\n");
    stream.println(sb.toString());
  }

  public void ASTDecl.jjtGenVisitor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println(ind + "public Object " + name() + ".jjtAccept(" + parserName + "Visitor visitor, Object data) {\n" +
        ind(2) + "return visitor.visit(this, data);\n" + 
        ind + "}\n");
  }

  public void ASTDecl.jjtGenConstructor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String finalInit = "";
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        finalInit = ind(2) + "is$Final(state().rewritePhase);\n";
      else
        finalInit = ind(2) + "is$Final(true);\n";
    }
    String s;
    if(jjtree) {
      s = ind + "public #ID#.#ID#(int i) {\n" +
        ind(2) + "super(i);\n" + finalInit +
        ind + "}\n" +
        ind + "public #ID#.#ID#(" + parserName + " p, int i) {\n" +
        ind(2) + "this(i);\n" +
        ind(2) + "parser = p;\n" + finalInit +
        ind + "}\n" +
        ind + "public #ID#.#ID#() {\n" + 
        ind(2) + "this(0);\n" + 
        "#NTA#";
    }
    else {
      s = ind + "public #ID#.#ID#() {\n" + // Lgg till null fr agg, tom lista fr list, false fr opt
        ind(2) + "super();\n" + 
        "#NTA#";
    }
    String t = new String();
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponentsNTA) {
        //t = t + ind(2) + "setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof OptionalComponentNTA) {
        //t = t + ind(2) + "setChild(new Opt(), " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof AggregateComponentsNTA) {
        //t = t + ind(2) + "setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
    }
    s = s.replaceAll("#ID#", name());
    s = s.replaceAll("#NTA#", t);
    stream.println(s);
    // Initialize node
    i = 0;
    // ES_2011-11-23: Code generation for incremental evaluation  
    if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorStartConstruction());
    //
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponents) {
        stream.println(ind(2) + "setChild(new List(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof OptionalComponent) {
        stream.println(ind(2) + "setChild(new Opt(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof AggregateComponents) {
        //stream.println(ind(2) + "setChild(null, " + String.valueOf(i) + ");");
        i++;
      }
    }
    // ES_2011-11-23: Code generation for incremental evaluation  
    if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorEndConstruction());
    //
    stream.println(finalInit);
    stream.println(ind + "}\n");

    if(numNonNTAComponents() != 0) {
      emitBuildingConstructor(stream);
      if(ASTNode.beaver)
        stream.print(buildingSymbolConstructor());
    }

    if(name().equals("Opt")) {
      if(ASTNode.java5)
        stream.println(ind + "public Opt.Opt(T opt) {");
      else
        stream.println(ind + "public Opt.Opt(ASTNode opt) {");
      // ES_2011-11-23: Code generation for incremental evaluation  
      if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorStartConstruction());
      //
      stream.println(ind(2) + "setChild(opt, 0);");
      // ES_2011-11-23: Code generation for incremental evaluation  
      if (ASTNode.incremental) stream.println(ind(2) + genIncrementalConstructorEndConstruction());
      //
      stream.println(ind + "}\n");
    }

  }

  public void ASTDecl.jjtGen(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String s;

    jjtGenConstructor(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenCloneNode(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenFlushCache(stream);
    if(jjtree) {
      jjtGenDumpTree(stream, parserName, jjtree, rewriteEnabled);
      jjtGenVisitor(stream, parserName, jjtree, rewriteEnabled);
      try {
        jjtGenCheckTreeStructure(stream);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }

    // Generate code common for all nodes by adding them to ASTNode
    if(name().equals("ASTNode")) {
      jjtGenASTNode(stream, parserName, jjtree, rewriteEnabled);
      env().genRewriteOrderChecks(stream);
      env().genReset(stream);
      if(ASTNode.java5) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public java.util.Iterator<T> ASTNode.iterator() {");
        if(ASTNode.block) stream.append(ASTNode.blockBegin);
        stream.println(ind(2) + "return new java.util.Iterator<T>() {");
        stream.println(ind(3) + "private int counter = 0;");
        stream.println(ind(3) + "public boolean hasNext() {");
        stream.println(ind(4) + "return counter < getNumChild();");
        stream.println(ind(3) + "}");
        stream.println(ind(3) + "@SuppressWarnings(\"unchecked\") public T next() {");
        stream.println(ind(4) + "if(hasNext())");
        stream.println(ind(5) + "return (T)getChild(counter++);");
        stream.println(ind(4) + "else");
        stream.println(ind(5) + "return null;");
        stream.println(ind(3) + "}");
        stream.println(ind(3) + "public void remove() {");
        stream.println(ind(4) + "throw new UnsupportedOperationException();");
        stream.println(ind(3) + "}");
        stream.println(ind(2) + "};");
        if(ASTNode.block) stream.append(ASTNode.blockEnd);
        stream.println(ind + "}");
      }
    }
    else if(name().equals("List")) {
      if(ASTNode.java5)
        stream.println(ind + "public List<T> List.add(T node) {");
      else
        stream.println(ind + "public List List.add(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      if(debugMode) {
        stream.println(ind(2) + "if(node instanceof List)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type List\");");
        stream.println(ind(2) + "if(node instanceof Opt)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type Opt\");");
      }
      stream.println(ind(2) + "addChild(node);");
      stream.println(ind(2) + "return this;");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}\n");
      stream.println(ind + "public void List.insertChild(ASTNode node, int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
      //
      stream.println(ind(2) + "list$touched = true;");
      stream.println(ind(2) + "super.insertChild(node, i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      if(ASTNode.java5)
        stream.println(ind + "public void List.addChild(T node) {");
      else
        stream.println(ind + "public void List.addChild(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
      //
      stream.println(ind(2) + "list$touched = true;");
      stream.println(ind(2) + "super.addChild(node);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void List.removeChild(int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
        stream.println(ind(2) + "list$touched = true;");
      //
      stream.println(ind(2) + "super.removeChild(i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "public int List.getNumChild() {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) {
        stream.println(ind(2) + "if(list$touched) {");
        stream.println(ind(3) + "for(int i = 0; i < getNumChildNoTransform(); i++)");
        stream.println(ind(4) + "getChild(i);");
        stream.println(ind(4) + "list$touched = false;");
        stream.println(ind(3) + "}");
      } 
      //
      stream.println(ind(3) + "return getNumChildNoTransform();");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
      if (!(ASTNode.incremental || ASTNode.fullFlush)) 
        stream.println(ind + "private boolean List.list$touched = true;");
    }
    else if(name().equals("Opt")) {
      // do not override getNumChild with implementation below
    }
    else {

      if(jjtree) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public int " + name() + ".getNumChild() {");
        // ES_2011-09-20: Code generation for incremental evaluation, tracking numChild
        if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
        // 
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "protected int " +name() + ".numChildren() {");
        // ES_2011-09-20: Code generation for incremental evaluation, tracking numChild
        if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
        // 
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      if(debugMode && isRootNode()) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "protected boolean " + name() + ".debugNodeAttachmentIsRoot() { return true; }");
      }
    }
    if(rewriteEnabled) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean " + name() + ".mayHaveRewrite() {");
      if(name().equals("List")) {
        // ES_2011-10-10: Code generation for incremental evaluation, avoiding list touch rewrite
        if (!(ASTNode.incremental || ASTNode.fullFlush)) {
          // old code 
          stream.println(ind(2) + "return true;");
        } else {
          stream.println(ind(2) + "return false;");
        }
      } else if(!hasRewrites())
        stream.println(ind(2) + "return false;");
      else if(!stagedRewrites || rewriteWithNoPhaseCondition())
        stream.println(ind(2) + "return true;");
      else {
        for(Iterator iter = rewritePhaseConditions().iterator(); iter.hasNext(); ) {
          String condition = (String)iter.next();
          stream.println(ind(2) + "if(" + condition + ") return true;");
        }
        stream.println(ind(2) + "return false;");
      }
      stream.println(ind + "}");
    }

    // ES_2011-09-19: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncremental(stream);
  }

  syn boolean ASTDecl.rewriteWithNoPhaseCondition() {
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() == null)
        return true;
      String condition = Unparser.unparse(getRewrite(i).getCondition());
      if(condition.indexOf("inRewritePhase") == -1 && condition.indexOf("inExactRewritePhase") == -1)
        return true;
    }
    return superClass() instanceof ASTDecl && ((ASTDecl)superClass()).rewriteWithNoPhaseCondition();
  }

  syn java.util.Set ASTDecl.rewritePhaseConditions() {
    java.util.Set set = new java.util.LinkedHashSet();
    Pattern p = Pattern.compile("inRewritePhase\\([\\w\\.]*\\)|inExactRewritePhase\\([\\w\\.]*\\)");
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() != null) {
        String condition = Unparser.unparse(getRewrite(i).getCondition());
        Matcher m = p.matcher(condition);
        while(m.find()) {
          String match = m.group();
          set.add(match);
        }
      }
    }
    if(superClass() instanceof ASTDecl)
      set.addAll(((ASTDecl)superClass()).rewritePhaseConditions());
    return set;
  }

  public abstract void Components.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl);

  String ListComponents.setNameListComment() {
    return ind + "/**\n" +
      ind + " * Replaces the #NAME# list.\n" +
      ind + " * @param list The new list node to be used as the #NAME# list.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNumNameComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the number of children in the #NAME# list.\n" +
      ind + " * @return Number of children in the #NAME# list.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNameComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the element at index {@code i} in the #NAME# list..\n" +
      ind + " * @param i Index of the element to return.\n" +
      ind + " * @return The element at position {@code i} in the #NAME# list.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.addNameComment() {
    return ind + "/**\n" +
      ind + " * Append an element to the #NAME# list.\n" +
      ind + " * @param node The element to append to the #NAME# list.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.setNameComment() {
    return ind + "/**\n" +
      ind + " * Replaces the #NAME# list element at index {@code i} with the new node {@code node}.\n" +
      ind + " * @param node The new node to replace the old list element.\n" +
      ind + " * @param i The list index of the node to be replaced.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNameListComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the #NAME# list.\n" +
      ind + " * @return The node representing the #NAME# list.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }


  public void ListComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String s;
    String name = decl.name();
    // Generate getNum- and get-method for the list component
    s = setNameListComment() +
      ind + "public void #HOST#.set#NAME#List(#LISTTYPE# list) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "setChild(list, #INDEX#);\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      //ind + "private int #HOST#.getNum#NAME# = 0;\n" +
      getNumNameComment() +
      ind + "public int #HOST#.getNum#NAME#() {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return get#NAME#List().getNumChild();\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      ind + "/**\n" +
      ind + " * Retrieves the number of children in the #NAME# list.\n" +
      ind + " * Calling this method will not trigger rewrites..\n" +
      ind + " * @return Number of children in the #NAME# list.\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n" +
      ind + "public int #HOST#.getNum#NAME#NoTransform() {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return get#NAME#ListNoTransform().getNumChildNoTransform();\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      getNameComment() +
      "#ANNOTATIONS#" +
      ind + "public #TYPE# #HOST#.get#NAME#(int i) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return (#TYPE#)get#NAME#List().getChild(i);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      addNameComment() +
      ind + "public void #HOST#.add#NAME#(#TYPE# node) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = (parent == null || state == null) ? get#NAME#ListNoTransform() : get#NAME#List();\n" +
      ind(2) + "list.addChild(node);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      ind + "/**\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n" +
      ind + "public void #HOST#.add#NAME#NoTransform(#TYPE# node) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = get#NAME#ListNoTransform();\n" +
      ind(2) + "list.addChild(node);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node, int i) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = get#NAME#List();\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "list.setChild(node, i);\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(ASTNode.java5) {
      s +=
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# list.\n" +
        ind + " * @return The node representing the #NAME# list.\n" +
        ind + " * @apilevel high-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#s() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return get#NAME#List();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# list.\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The node representing the #NAME# list.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#sNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return get#NAME#ListNoTransform();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    if(!isNTA()) {
      s +=
        getNameListComment() +
        "#ANNOTATIONS#" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#List() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "#LISTTYPE# list = (#LISTTYPE#)getChild(#INDEX#);\n" +
        ind(2) + "list.getNumChild();\n" +
        ind(2) + "return list;\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" + 
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# list.\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The node representing the #NAME# list.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# list.\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The node representing the #NAME# list.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * Retrieves the child position of the #NAME# list.\n" +
        ind + " * @return The the child position of the #NAME# list.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#ListChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#LISTTYPE#", ASTNode.java5 ? "List<" + getId().type() + ">" : "List");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }

  String OptionalComponent.setNameOptComment() {
    return ind + "/**\n" +
      ind + " * Replaces the optional node for the #NAME# child. This is the {@code Opt} node containing the child #NAME#, not the actual child!\n" +
      ind + " * @param opt The new node to be used as the optional node for the #NAME# child.\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.hasNameComment() {
    return ind + "/**\n" +
      ind + " * Check whether the optional #NAME# child exists.\n" +
      ind + " * @return {@code true} if the optional #NAME# child exists, {@code false} if it does not.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.getNameComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the (optional) #NAME# child.\n" +
      ind + " * @return The #NAME# child, if it exists. Returns {@code null} otherwise.\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.setNameComment() {
    return ind + "/**\n" +
      ind + " * Replaces the (optional) #NAME# child.\n" +
      ind + " * @param node The new node to be used as the #NAME# child.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.getNameOptComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the optional node for the #NAME# child. This is the {@code Opt} node containing the child #NAME#, not the actual child!\n" +
      ind + " * @return The optional node for child the #NAME# child.\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n";
  }

  public void OptionalComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate has- and get-method for the optional component
    s = setNameOptComment() +
      ind + "public void #HOST#.set#NAME#Opt(#OPTTYPE# opt) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "setChild(opt, #INDEX#);\n" + 
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      hasNameComment() +
      ind + "public boolean #HOST#.has#NAME#() {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return get#NAME#Opt().getNumChild() != 0;\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      getNameComment() +
      "#ANNOTATIONS#" +
      ind + "public #TYPE# #HOST#.get#NAME#() {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return (#TYPE#)get#NAME#Opt().getChild(0);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "get#NAME#Opt().setChild(node, 0);\n" +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(!isNTA()) {
      s +=
        getNameOptComment() +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#Opt() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChild(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * Retrieves the optional node for child #NAME#. This is the {@code Opt} node containing the child #NAME#, not the actual child!\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The optional node for child #NAME#.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * Retrieves the optional node for child #NAME#. This is the {@code Opt} node containing the child #NAME#, not the actual child!\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The optional node for child #NAME#.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * Retrieves the child position of the optional child #NAME#.\n" +
        ind + " * @return The the child position of the optional child #NAME#.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#OptChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#OPTTYPE#", ASTNode.java5 ? "Opt<" + getId().type() + ">" : "Opt");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }


  String TokenComponent.setIDComment() {
    return ind + "/**\n" +
      ind + " * Replaces the lexeme #ID#.\n" +
      ind + " * @param value The new value for the lexeme #ID#.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String TokenComponent.getIDComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the value for the lexeme #ID#.\n" +
      ind + " * @return The value for the lexeme #ID#.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  private boolean TokenComponent.called = false;
  public void TokenComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    StringBuffer buf = new StringBuffer();
    // Generate attribute, get- and set-method for the token string
    buf.append(setIDComment());
    buf.append(
        // ES_2011-09-20: Code generation for incremental evaluation
        (ASTNode.incremental ? jaddGenIncrementalTokenHandler() : "") +
        //
        ind + "public void #HOST#.set#ID#(#TYPE# value) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "token#TYPEINSIGNATURE#_#ID# = value;\n" +
        // ES_2011-09-20: Code generation for incremental evaluation
        (ASTNode.incremental ? jaddGenIncrementalTokenChange("value") : "") +
        //
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n"
        );
    if(decl.redefinesTokenComponent(this)) {
      buf.append(ind + "/**\n");
      buf.append(ind + " * @apilevel internal\n");
      buf.append(ind + " */\n");
      buf.append(ind + "protected #TYPE# #HOST#.token#TYPEINSIGNATURE#_#ID#;\n");
    }
    if(!isNTA()) {
      boolean isStringToken = getTokenId().getTYPE().equals("String") || getTokenId().getTYPE().equals("java.lang.String");
      if(isStringToken && ASTNode.beaver) {
        if(decl.redefinesTokenComponent(this)) {
          buf.append(
              ind + "public int #HOST#.#ID#start;\n" +
              ind + "public int #HOST#.#ID#end;\n"
              );
        }
        buf.append(
            ind + "/**\n" +
            ind + " * JastAdd-internal setter for lexeme #ID# using the Beaver parser.\n" +
            ind + " * @apilevel internal\n" +
            ind + " */\n" +
            ind + "public void #HOST#.set#ID#(beaver.Symbol symbol) {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            ind(2) + "if(symbol.value != null && !(symbol.value instanceof String))\n" +
            ind(3) + "throw new UnsupportedOperationException(\"set#ID# is only valid for String lexemes\");\n" +
            ind(2) + "token#TYPEINSIGNATURE#_#ID# = (String)symbol.value;\n" +
            ind(2) + "#ID#start = symbol.getStart();\n" +
            ind(2) + "#ID#end = symbol.getEnd();\n" +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenChange("symbol") : "") + 
            //
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n"
            );
      }
      if(isStringToken)
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenTrack() : "") +
            //
            ind(2) + "return token#TYPEINSIGNATURE#_#ID# != null ? token#TYPEINSIGNATURE#_#ID# : \"\";\n" +
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n");
      else
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenTrack() : "") +
            //
            ind(2) + "return token#TYPEINSIGNATURE#_#ID#;\n" +
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n");
    }
    String s = buf.toString();
    s = s.replaceAll("#ID#", getTokenId().getID());
    s = s.replaceAll("#TYPE#", getTokenId().getTYPE());
    s = s.replaceAll("#TYPEINSIGNATURE#", ASTNode.convTypeNameToSignature(getTokenId().getTYPE()));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);

  }


  String AggregateComponents.setNameComment() {
    return ind + "/**\n" +
      ind + " * Replaces the #NAME# child.\n" +
      ind + " * @param node The new node to replace the #NAME# child.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String AggregateComponents.getNameComment() {
    return ind + "/**\n" +
      ind + " * Retrieves the #NAME# child.\n" +
      ind + " * @return The current node used as the #NAME# child.\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }

  public void AggregateComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate get-method for component
    s = setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorStartConstruction(): "") +
      //
      ind(2) + "setChild(node, #INDEX#);\n" + 
      // ES_2011-11-23: Code generation for incremental evaluation  
      (ASTNode.incremental ? ind(2) + genIncrementalConstructorEndConstruction(): "") +
      //
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(!isNTA()) {
      s +=
        getNameComment() +
        ind + "public #TYPE# #HOST#.get#NAME#() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChild(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" + 
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# child.\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The current node used as the #NAME# child.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * Retrieves the #NAME# child.\n" +
        ind + " * <p><em>This method does not invoke AST transformations.</em></p>\n" +
        ind + " * @return The current node used as the #NAME# child.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * Retrieves the child position of the optional child #NAME#.\n" +
        ind + " * @return The the child position of the optional child #NAME#.\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#ChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }

  protected void Components.parse(String s) {
    jrag.AST.JragParser jp = new jrag.AST.JragParser(new java.io.StringReader(s));
    jp.root = hostClass().env();

    // The file name is not meaningful, as the component is completely generated
    // from a node type specification
    jp.setFileName("");

    // EMMA_2011-09-08: Adding this to give .ast generated methods an enclosing 
    // aspect "Ast" which allows for refinement of these methods. For example,
    // "getA" generated from "B ::= A" can be refined using the "Ast" aspect.
    //jp.enclosingAspect = "Ast";

    try {
      while(true)
        jp.AspectBodyDeclaration();
    } catch (Exception e) {
    }
  }
}
