import ast.AST.*;

import java.io.*;
import java.util.*;
import java.util.regex.*;

aspect JaddCodeGen {
  public void Grammar.abstractAncestors() {
    ASTDecl cl;
    IdDecl name;
    
    // Add ASTNode
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("ASTNode");
    cl.setIdDecl(name);
    cl.setFileName("ASTNode.ast");
    addTypeDecl(cl);
    
    // Add List
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("List");
    cl.setIdDecl(name);
    cl.setFileName("List.ast");
    addTypeDecl(cl);

    // Add Opt
    cl = new ASTDecl();
    name = new IdDecl();
    name.setID("Opt");
    cl.setIdDecl(name);
    cl.setFileName("Opt.ast");
    addTypeDecl(cl);
  }

  syn int ASTDecl.numNonNTAComponents() {
    int num = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        num++;
      }
    }
    return num;
  }

  syn int ASTDecl.numRegularChildren() {
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && !(c instanceof TokenComponent)) {
        i++;
      }
    }
    return i;
  }

  // Constructor to build trees bottom up
  public String ASTDecl.buildingConstructor() {
    // we only build constructors if there are components
    if(!getComponents().hasNext())
      return "";
    StringBuffer s = new StringBuffer();
    s.append(ind + "public #ID#.#ID#(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) s.append(", ");
        s.append(c.constrParmType() + " p" + i);
        i++;
      }
    }
    s.append(") {\n");
    if(ASTNode.block) s.append(ASTNode.blockBegin);
    i = 0;
    int j = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          s.append(ind(2) + "set" + t.getTokenId().getID() + "(p" + i + ");\n");
        }
        else {
          s.append(ind(2) + "setChild(p" + String.valueOf(i) + ", " + j + ");\n");
          j++;
        }
        i++;
      }
      else {
        if(c instanceof ListComponents) {
          s.append(ind(2) + "setChild(new List(), " + j + ");\n");
          j++;
        }
        else if(c instanceof OptionalComponent) {
          s.append(ind(2) + "setChild(new Opt(), " + j + ");\n");
          j++;
        }
        else if(c instanceof AggregateComponents) {
          s.append(ind(2) + "setChild(null, " + j + ");\n");
          j++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        s.append(ind(2) + "is$Final(java.lang.Integer.MAX_VALUE);\n");
      else
        s.append(ind(2) + "is$Final(true);\n");
    }
    if(ASTNode.block) s.append(ASTNode.blockEnd);
    s.append(ind + "}\n");
    return s.toString().replaceAll("#ID#", name());
  }

  public String ASTDecl.buildingSymbolConstructor() {
    // we only build constructors if there are components ...
    if(!getComponents().hasNext())
      return "";
    // ... and one of these components is a string token component
    boolean stringArg = false;
    for(Iterator iter = getComponents(); !stringArg && iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA() && c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
        stringArg = true;
    }
    if(!stringArg) return "";

    StringBuffer s = new StringBuffer();
    s.append(ind + "public #ID#.#ID#(");
    int i = 0; // parameter index
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(i != 0) s.append(", ");
        if(c instanceof TokenComponent && c.constrParmType().equals("String") || c.constrParmType().equals("java.lang.String"))
          s.append("beaver.Symbol p" + i);
        else
          s.append(c.constrParmType() + " p" + i);
        i++;
      }
    }
    s.append(") {\n");
    if(ASTNode.block) s.append(ASTNode.blockBegin);
    i = 0;
    int j = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(!c.isNTA()) {
        if(c instanceof TokenComponent) {
          TokenComponent t = (TokenComponent)c;
          s.append(ind(2) + "set" + t.getTokenId().getID() + "(p" + i + ");\n");
        }
        else {
          s.append(ind(2) + "setChild(p" + String.valueOf(i) + ", " + j + ");\n");
          j++;
        }
        i++;
      }
      else {
        if(c instanceof ListComponents) {
          s.append(ind(2) + "setChild(new List(), " + j + ");\n");
          j++;
        }
        else if(c instanceof OptionalComponent) {
          s.append(ind(2) + "setChild(new Opt(), " + j + ");\n");
          j++;
        }
        else if(c instanceof AggregateComponents) {
          s.append(ind(2) + "setChild(null, " + j + ");\n");
          j++;
        }
      }
    }
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        s.append(ind(2) + "is$Final(java.lang.Integer.MAX_VALUE);\n");
      else
        s.append(ind(2) + "is$Final(true);\n");
    }
    if(ASTNode.block) s.append(ASTNode.blockEnd);
    s.append(ind + "}\n");
    return s.toString().replaceAll("#ID#", name());
  }

  public void Grammar.genReset(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode$State.reset() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(circularEnabled) {
      stream.println(ind(2) + "IN_CIRCLE = false;");
      stream.println(ind(2) + "CIRCLE_INDEX = 1;"); // TOBBE
      stream.println(ind(2) + "CHANGE = false;");
      if(cacheCycle)
          stream.println(ind(2) + "LAST_CYCLE = false;");
      if(componentCheck) {
          stream.println(ind(2) + "circularEvalSet = " + ASTNode.createDefaultSet + ";");
          stream.println(ind(2) + "circularEvalStack = new java.util.Stack();");
      }
    }
    if(rewriteEnabled) {
      stream.println(ind(2) + "boundariesCrossed = 0;");
      genResetDuringCounters(stream);
      if(rewriteLimit > 0)
        stream.println(ind(2) + "debugRewrite = " + ASTNode.createDefaultMap + ";\n");
      if(stagedRewrites)
        stream.println(ind(2) + "rewritePhase = 1;\n");
    }
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
  }

  public void Grammar.jjtGenASTNode$State(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println("/**");
    stream.println(" * @apilevel internal");
    stream.println(" */");
    stream.println("static public class ASTNode$State {");
    if(circularEnabled) {
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean IN_CIRCLE = false;");
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public int CIRCLE_INDEX = 1;");
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean CHANGE = false;");
      if(cacheCycle) {
        stream.println("/**");
        stream.println(" * @apilevel internal");
        stream.println(" */");
        stream.println(ind + "public boolean LAST_CYCLE = false;");
      }
      stream.println("/**");
      stream.println(" * @apilevel internal");
      stream.println(" */");
      stream.println(ind + "public boolean RESET_CYCLE = false;");

      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static public class CircularValue {");
      stream.println(ind(2) + "Object value;");
      stream.println(ind(2) + "int visited = -1;");
      stream.println(ind + "}");

      if(componentCheck) {
        stream.println(ind + "public " + ASTNode.typeDefaultSet + " circularEvalSet = " + ASTNode.createDefaultSet + ";");
        stream.println(ind + "public java.util.Stack circularEvalStack = new java.util.Stack();");

        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "static class CircularEvalEntry {");
        stream.println(ind(2) + "ASTNode node;");
        stream.println(ind(2) + "String attrName;");
        stream.println(ind(2) + "Object parameters;");

        stream.println(ind(2) + "public CircularEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(3) + "this.node = node;");
        stream.println(ind(3) + "this.attrName = attrName;");
        stream.println(ind(3) + "this.parameters = parameters;");
        stream.println(ind(2) + "}");

        stream.println(ind(2) + "public boolean equals(Object rhs) {");
        stream.println(ind(3) + "CircularEvalEntry s = (CircularEvalEntry) rhs;");
        stream.println(ind(3) + "if (parameters == null && s.parameters == null)");
        stream.println(ind(4) + "return node == s.node && attrName.equals(s.attrName);");
        stream.println(ind(3) + "else if (parameters != null && s.parameters != null)");
        stream.println(ind(4) + "return node == s.node && attrName.equals(s.attrName) && parameters.equals(s.parameters);");
        stream.println(ind(3) + "else");
        stream.println(ind(4) + "return false;");
        stream.println(ind(2) + "}");

        stream.println(ind(2) + "public int hashCode() {");
        stream.println(ind(3) + "return node.hashCode();");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");

        stream.println(ind + "public void addEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(2) + "circularEvalSet.add(new CircularEvalEntry(node,attrName,parameters));");
        stream.println(ind + "}");

        stream.println(ind + "public boolean containsEvalEntry(ASTNode node, String attrName, Object parameters) {");
        stream.println(ind(2) + "return circularEvalSet.contains(new CircularEvalEntry(node,attrName,parameters));");
        stream.println(ind + "}");

        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "static class CircularStackEntry {");
        stream.println(ind(2) + "" + ASTNode.typeDefaultSet + " circularEvalSet;");
        stream.println(ind(2) + "boolean changeValue;");

        stream.println(ind(2) + "public CircularStackEntry(" + ASTNode.typeDefaultSet + " set, boolean change) {");
        stream.println(ind(3) + "circularEvalSet = set;");
        stream.println(ind(3) + "changeValue = change;");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");

        stream.println(ind + "public void pushEvalStack() {");
        stream.println(ind(2) + "circularEvalStack.push(new CircularStackEntry(circularEvalSet, CHANGE));");
        stream.println(ind(2) + "circularEvalSet = " + ASTNode.createDefaultSet + ";");
        stream.println(ind(2) + "CHANGE = false;");
        stream.println(ind + "}");

        stream.println(ind + "public void popEvalStack() {");
        stream.println(ind(2) + "CircularStackEntry c = (CircularStackEntry) circularEvalStack.pop();");
        stream.println(ind(2) + "circularEvalSet = c.circularEvalSet;");
        stream.println(ind(2) + "CHANGE = c.changeValue;");
        stream.println(ind + "}");

      }
    }
    if(rewriteEnabled) {
      stream.println(ind + "public static final int REWRITE_CHANGE = 1;");
      stream.println(ind + "public static final int REWRITE_NOCHANGE = 2;");
      stream.println(ind + "public static final int REWRITE_INTERRUPT = 3;");
      if(rewriteLimit > 0) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public java.util.HashMap debugRewrite = " + ASTNode.createDefaultMap + ";\n");
      }
      stream.println(ind + "public int boundariesCrossed = 0;\n");
      if(stagedRewrites)
        stream.println(ind + "public int rewritePhase = 1;");
      // state code
      stream.println(ind + "private int[] stack;");
      stream.println(ind + "private int pos;");
      stream.println(ind + "public ASTNode$State() {");
      stream.println(ind(3) + "stack = new int[64];");
      stream.println(ind(3) + "pos = 0;");
      stream.println(ind + "}");
      stream.println(ind + "private void ensureSize(int size) {");
      stream.println(ind(3) + "if(size < stack.length)");
      stream.println(ind(4) + "return;");
      stream.println(ind(3) + "int[] newStack = new int[stack.length * 2];");
      stream.println(ind(3) + "System.arraycopy(stack, 0, newStack, 0, stack.length);");
      stream.println(ind(3) + "stack = newStack;");
      stream.println(ind + "}");
      stream.println(ind + "public void push(int i) {");
      stream.println(ind(2) + "ensureSize(pos+1);");
      stream.println(ind(2) + "stack[pos++] = i;");
      stream.println(ind + "}");
      stream.println(ind + "public int pop() {");
      stream.println(ind(2) + "return stack[--pos];");
      stream.println(ind + "}");
      stream.println(ind + "public int peek() {");
      stream.println(ind(2) + "return stack[pos-1];");
      stream.println(ind + "}");
    }

    if(j2me) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class HashtableBasedSet  {");
      stream.println(ind(2) + "public HashtableBasedSet(int initialCapacity) {");
      stream.println(ind(3) + "map = new java.util.Hashtable(initialCapacity);");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "private java.util.Hashtable map;");
      stream.println(ind(2) + "private static final Object PRESENT = new Object();");
      stream.println(ind(2) + "public java.util.Enumeration elements() { return map.keys(); }");
      stream.println(ind(2) + "public int size() { return map.size(); }");
      stream.println(ind(2) + "public boolean isEmpty() { return map.isEmpty(); }");
      stream.println(ind(2) + "public boolean contains(Object o) { return map.containsKey(o); }");
      stream.println(ind(2) + "public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
      stream.println(ind(2) + "public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
      stream.println(ind(2) + "public void clear() { map.clear(); }");
      stream.println(ind + "}");
    }
    else if(deterministic) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class IdentityHashSet extends java.util.LinkedHashSet {");
      stream.println(ind(2) + "public IdentityHashSet(int initialCapacity) { super(initialCapacity); }");
      stream.println(ind(2) + "/**");
      stream.println(ind(2) + " * @apilevel internal");
      stream.println(ind(2) + " */");
      stream.println(ind(2) + "public java.util.Iterator iterator() {");
      stream.println(ind(3) + "final java.util.Iterator i = super.iterator();");
      stream.println(ind(3) + "return new java.util.Iterator() {");
      stream.println(ind(4) + "public boolean hasNext() { return i.hasNext(); }");
      stream.println(ind(4) + "public Object next() { return ((Wrapper)i.next()).o; }");
      stream.println(ind(4) + "public void remove() { i.remove(); }");
      stream.println(ind(3) + "};");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "public boolean contains(Object o) { return super.contains(wrap(o)); }");
      stream.println(ind(2) + "public boolean add(Object o) { return super.add(wrap(o)); }");
      stream.println(ind(2) + "public boolean remove(Object o) { return super.remove(wrap(o)); }");
      stream.println(ind(2) + "private Wrapper wrap(Object o) { return new Wrapper(o); }");
      stream.println(ind(2) + "/**");
      stream.println(ind(2) + " * @apilevel internal");
      stream.println(ind(2) + " */");
      stream.println(ind(2) + "private static class Wrapper {");
      stream.println(ind(3) + "private Object o;");
      stream.println(ind(3) + "private Wrapper(Object o) { this.o = o; }");
      stream.println(ind(3) + "public boolean equals(Object other) { return other instanceof Wrapper && ((Wrapper)other).o == o; }");
      stream.println(ind(3) + "public int hashCode() { return System.identityHashCode(o); }");
      stream.println(ind(2) + "}");
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "static class IdentityHashSet extends java.util.AbstractSet implements java.util.Set {");
      stream.println(ind(2) + "public IdentityHashSet(int initialCapacity) {");
      stream.println(ind(3) + "map = new java.util.IdentityHashMap(initialCapacity);");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "private java.util.IdentityHashMap map;");
      stream.println(ind(2) + "private static final Object PRESENT = new Object();");
      stream.println(ind(2) + "public java.util.Iterator iterator() { return map.keySet().iterator(); }");
      stream.println(ind(2) + "public int size() { return map.size(); }");
      stream.println(ind(2) + "public boolean isEmpty() { return map.isEmpty(); }");
      stream.println(ind(2) + "public boolean contains(Object o) { return map.containsKey(o); }");
      stream.println(ind(2) + "public boolean add(Object o) { return map.put(o, PRESENT)==null; }");
      stream.println(ind(2) + "public boolean remove(Object o) { return map.remove(o)==PRESENT; }");
      stream.println(ind(2) + "public void clear() { map.clear(); }");
      stream.println(ind + "}");
    }

    // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
    if (ASTNode.incremental) jjtGenIncrementalEvaluationStack(stream);

    stream.println("}"); // End ASTNode$State
  }

  // ES_2011-09-20: Code generation for incremental evaluation, evaluation stack
  public void Grammar.jjtGenIncrementalEvaluationStack(PrintWriter stream) {
    stream.println(ind + "protected java.util.Stack handlerAttrStack = new java.util.Stack();");
    stream.println(ind + "protected java.util.Stack handlerRewriteStack = new java.util.Stack();");
    stream.println(ind + "public void addHandlerDepTo(ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (!IN_ATTR_STORE_EVAL && !IN_REWRITE_EVAL || handler == null) {");
    stream.println(ind(3) +   "return;");
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "java.util.Stack handlerStack = handlerAttrStack;");
    stream.println(ind(2) + "if (IN_REWRITE_EVAL) ");
    stream.println(ind(3) +   "handlerStack = handlerRewriteStack;");
    stream.println(ind(2) + "if (!handlerStack.isEmpty()) {");
    stream.println(ind(3) +   "//throw new Error(\"Handler stack is empty at addition of dependency!\");");
    stream.println(ind(3) +   "ASTNode$DepGraphNode top = (ASTNode$DepGraphNode)handlerStack.peek();");
    stream.println(ind(3) +   "handler.addDependant(top);");
    stream.println(ind(2) + "}");
    stream.println(ind + "}");
    stream.println(ind + "public boolean IN_ATTR_STORE_EVAL = false;");
    stream.println(ind + "public void enterAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = true;");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack enter: \" + handler.fAttrID);");
    stream.println(ind(3) +   "pushHandler(handlerAttrStack, handler);");
    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitAttrStoreEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "if (!IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "popHandler(handlerAttrStack, handler);");
    stream.println(ind(3) +   "//System.out.println(\"attr eval stack exit: \" + handler.fAttrID);");
    stream.println(ind(3) +   "IN_ATTR_STORE_EVAL = !handlerAttrStack.isEmpty();");
    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "public boolean IN_REWRITE_EVAL = false;");
    stream.println(ind + "public void enterRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "IN_REWRITE_EVAL = true;");
    stream.println(ind(2) + "pushHandler(handlerRewriteStack, handler);");
    stream.println(ind + "}"); 
    stream.println(ind + "public void exitRewriteEval(ASTNode$DepGraphNode handler) {"); 
    stream.println(ind(2) + "if (IN_REWRITE_EVAL) {");
    stream.println(ind(3) +   "popHandler(handlerRewriteStack, handler);");
    stream.println(ind(3) +   "IN_REWRITE_EVAL = !handlerRewriteStack.isEmpty();");
    stream.println(ind(2) + "}");
    stream.println(ind + "}"); 
    stream.println(ind + "protected void pushHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "stack.push(handler);");
    stream.println(ind + "}");        
    stream.println(ind + "protected ASTNode$DepGraphNode popHandler(java.util.Stack stack, ASTNode$DepGraphNode handler) {");
    stream.println(ind(2) + "if (stack.isEmpty())");
    stream.println(ind(3) +   "throw new Error(\"Handler stack is empty at exit!\");");
    stream.println(ind(2) + "ASTNode$DepGraphNode h = (ASTNode$DepGraphNode)stack.pop();");
    stream.println(ind(2) + "if (h != handler)");
    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop!\");");
//    stream.println(ind(3) +   "throw new Error(\"Top of handler stack does not match at pop! [\" + handler.fAttrID + \"]\");");
    stream.println(ind(2) + "return h;");
    stream.println(ind + "}");
  }

  public void ASTDecl.jjtGenASTNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithCircularEnabled = " + ASTNode.circularEnabled + ";");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithCacheCycle = " + ASTNode.cacheCycle + ";");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "public static final boolean ASTNode.generatedWithComponentCheck = " + ASTNode.componentCheck + ";");
    if(ASTNode.noStatic) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode$State ASTNode.state = null;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode$State ASTNode.state() {");
      stream.println(ind(2) + "if(state == null) {");
      stream.println(ind(3) + "if(parent == null) {");
      stream.println(ind(4) + "state = new ASTNode$State();");
      if(ASTNode.debugMode) {
        // check if a new state object is created for a node that is not a root node
        StringBuffer s = new StringBuffer();
        s.append("if(");
        boolean first = true;
        for(Iterator iter = env().roots().iterator(); iter.hasNext(); ) {
          ASTDecl root = (ASTDecl)iter.next();
          if(!first)
            s.append(" && ");
          first = false;
          s.append("!(this instanceof " + root.name() + ")");
        }
        s.append(") throw new RuntimeException(\"Trying to evaluate state in a node which is not attached to the main tree\");");
        stream.println(s.toString());
      }
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "else {");
      stream.println(ind(4) + "tate = parent.state();");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "return state;");
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected static ASTNode$State ASTNode.state = new ASTNode$State();");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode$State ASTNode.state() { return state; }");
    }


    if(rewriteEnabled) {
      if(rewriteLimit > 0) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.debugRewrite(String info) {");
        stream.println(ind(2) + "if(!parent.is$Final()) return;");
        stream.println(ind(2) + "java.util.ArrayList key = new java.util.ArrayList(2);");
        stream.println(ind(2) + "key.add(getParent());");
        stream.println(ind(2) + "key.add(new Integer(getParent().getIndexOfChild(this)));");
        stream.println(ind(2) + "java.util.ArrayList list;");
        stream.println(ind(2) + "if(state().debugRewrite.containsKey(key))");
        stream.println(ind(3) + "list = (java.util.ArrayList)state().debugRewrite.get(key);");
        stream.println(ind(2) + "else {");
        stream.println(ind(3) + "list = new java.util.ArrayList();");
        stream.println(ind(3) + "state().debugRewrite.put(key, list);");
        stream.println(ind(2) + "}");
        stream.println(ind(2) + "list.add(info);");
        stream.println(ind(2) + "if(list.size() > " + rewriteLimit + ") {");
        stream.println(ind(3) + "StringBuffer buf = new StringBuffer(\"Iteration count exceeded for rewrite:\");");
        stream.println(ind(3) + "for(java.util.Iterator iter = list.iterator(); iter.hasNext(); ) buf.append(\"\\n\" + iter.next());");
        stream.println(ind(3) + "throw new RuntimeException(buf.toString());");
        stream.println(ind(2) + "}");
        stream.println(ind + "}");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.debugRewriteRemove() {");
        stream.println(ind(2) + "java.util.ArrayList key = new java.util.ArrayList(2);");
        stream.println(ind(2) + "key.add(getParent());");
        stream.println(ind(2) + "key.add(new Integer(getParent().getIndexOfChild(this)));");
        stream.println(ind(2) + "state().debugRewrite.remove(key);");
        stream.println(ind + "}\n");
      }
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean ASTNode.in$Circle = false;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean ASTNode.in$Circle() { return in$Circle; }");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.in$Circle(boolean b) { in$Circle = b; }");
      if(ASTNode.stagedRewrites) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public int ASTNode.is$Final = 0;");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final() { return is$Final >= state().rewritePhase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.is$Final(int phase) { is$Final = phase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.enterRewritePhase(int phase) { state().rewritePhase = phase; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.inRewritePhase(int phase) { return state().rewritePhase >= phase; }");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final = false;");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public boolean ASTNode.is$Final() { return is$Final; }");
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "public void ASTNode.is$Final(boolean b) { is$Final = b; }");
      }
      if(ASTNode.java5) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "@SuppressWarnings(\"cast\") public T ASTNode.getChild(int i) {");
        // ES_2011-09-20: Code generation for incremental evaluation
        if (ASTNode.incremental) {
          stream.println(ind(2) + "T child = (T)ASTNode.getChild(this, i);");
          jjtGenIncrementalTrackGetChild(stream);
          stream.println(ind(2) + "return child;");        
        } else 
        //
        stream.println(ind(2) + "return (T)ASTNode.getChild(this, i);");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public ASTNode ASTNode.getChild(int i) {");
        // ES_2011-09-20: Code generation for incremental evaluation
        if (ASTNode.incremental) { 
          stream.println(ind(2) + "ASTNode child = ASTNode.getChild(this, i);");
          jjtGenIncrementalTrackGetChild(stream);
          stream.println(ind(2) + "return child;");
        } else 
        //
        stream.println(ind(2) + "return ASTNode.getChild(this, i);");
        stream.println(ind + "}");
      }
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public static ASTNode ASTNode.getChild(ASTNode that, int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      stream.println(ind(2) + "ASTNode node = that.getChildNoTransform(i);");
      stream.println(ind(2) + "if(node.is$Final()) return node;");
      stream.println(ind(2) + "if(!node.mayHaveRewrite()) {");
      if(ASTNode.stagedRewrites)
        stream.println(ind(3) + "node.is$Final(that.is$Final);");
      else
        stream.println(ind(3) + "node.is$Final(that.is$Final());");
      stream.println(ind(3) + "return node;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if(!node.in$Circle()) {");
      stream.println(ind(3) + "int rewriteState;");
      stream.println(ind(3) + "int num = that.state().boundariesCrossed;");
      stream.println(ind(3) + "do {");
      stream.println(ind(4) + "that.state().push(ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(4) + "ASTNode oldNode = node;");
      stream.println(ind(4) + "oldNode.in$Circle(true);");
      stream.println(ind(4) + "node = node.rewriteTo();");
      stream.println(ind(4) + "if(node != oldNode)");
      stream.println(ind(5) + "that.setChild(node, i);");
      stream.println(ind(4) + "oldNode.in$Circle(false);");
      stream.println(ind(4) + "rewriteState = that.state().pop();");
      stream.println(ind(3) + "} while(rewriteState == ASTNode$State.REWRITE_CHANGE);");
      stream.println(ind(3) + "if(rewriteState == ASTNode$State.REWRITE_NOCHANGE && that.is$Final()) {");
      if(ASTNode.stagedRewrites)
        stream.println(ind(4) + "node.is$Final(that.state().rewritePhase);");
      else
        stream.println(ind(4) + "node.is$Final(true);");
      stream.println(ind(4) + "that.state().boundariesCrossed = num;");
      if(rewriteLimit > 0)
        stream.println(ind(4) + "node.debugRewriteRemove();");
      stream.println(ind(3) + "}");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "else if(that.is$Final() != node.is$Final()) that.state().boundariesCrossed++;");
      stream.println(ind(2) + "return node;");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    else {
      if(ASTNode.java5) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "@SuppressWarnings(\"cast\")");
        stream.println(ind + "public T ASTNode.getChild(int i) {");
        // ES_2011-09-20: Code generation for incremental evaluation
        if (ASTNode.incremental) {
          stream.println(ind(2) + "T child = (T)getChildNoTransform(i);");
          jjtGenIncrementalTrackGetChild(stream);
          stream.println(ind(2) + "return child;");        
        } else 
        //
        stream.println(ind(2) + "return (T)getChildNoTransform(i);");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public ASTNode ASTNode.getChild(int i) {");
        // ES_2011-09-20: Code generation for incremental evaluation
        if (ASTNode.incremental) {
          stream.println(ind(2) + "ASTNode child = getChildNoTransform(i);");
          jjtGenIncrementalTrackGetChild(stream);
          stream.println(ind(2) + "return child;");        
        } else 
        //
        stream.println(ind(2) + "return getChildNoTransform(i);");
        stream.println(ind + "}");
      }
    }
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.println(ind + "private int ASTNode.childIndex;");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public int ASTNode.getIndexOfChild(ASTNode node) {");
    stream.println(ind(2) + "if(node != null && node.childIndex < getNumChildNoTransform() && node == getChildNoTransform(node.childIndex))");
    stream.println(ind(3) + "return node.childIndex;");
    stream.println(ind(2) + "for(int i = 0; i < getNumChildNoTransform(); i++)");
    stream.println(ind(3) + "if(getChildNoTransform(i) == node) {");
    stream.println(ind(4) + "node.childIndex = i;");
    stream.println(ind(4) + "return i;");
    stream.println(ind(3) + "}");
    stream.println(ind(2) + "return -1;");
    stream.println(ind + "}\n");
    if(ASTNode.java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.addChild(T node) {");
    } else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void ASTNode.addChild(ASTNode node) {");
    }
    stream.println(ind(2) + "setChild(node, getNumChildNoTransform());");
    stream.println(ind + "}");


    if(ASTNode.java5) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "@SuppressWarnings(\"cast\")");
      stream.println(ind + "public final T ASTNode.getChildNoTransform(int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      // ES_2011-09-20: Code generation for incremental evaluation
      if (ASTNode.incremental) {
        stream.println(ind(2) + "T child = (T)children[i];");
        jjtGenIncrementalTrackGetChild(stream);
        stream.println(ind(2) + "return child;");        
      } else 
      //
      stream.println(ind(2) + "return (T)children[i];");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public final ASTNode ASTNode.getChildNoTransform(int i) {");
      if(ASTNode.block) stream.print(ASTNode.blockBegin);
      // ES_2011-09-20: Code generation for incremental evaluation
      if (ASTNode.incremental) {
        stream.println(ind(2) + "ASTNode child = (ASTNode)children[i];");
        jjtGenIncrementalTrackGetChild(stream);
        stream.println(ind(2) + "return child;");        
      } else 
      //
      stream.println(ind(2) + "return (ASTNode)children[i];");
      if(ASTNode.block) stream.print(ASTNode.blockEnd);
      stream.println(ind + "}");
    }
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren;"); // added
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "protected int ASTNode.numChildren() {");
    stream.println(ind(2) + "return numChildren;");
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public int ASTNode.getNumChild() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    // ES_2011-09-20: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
    stream.println(ind(2) + "return numChildren();");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public final int ASTNode.getNumChildNoTransform() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    stream.println(ind(2) + "return numChildren();");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.setChild(ASTNode node, int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(debugMode)
      stream.println(ind(2) + "debugNodeAttachment(node);");
    stream.println(ind + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[i + 1];");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild1(stream);
    //
    stream.println(ind + "} else if (i >= children.length) {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[i << 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, children.length);");
    stream.println(ind(3) + "children = c;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild2(stream);
    //
    stream.println(ind(2) + "}");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild3(stream);
    //
    stream.println(ind(2) + "children[i] = node;");
    stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeSetChild4(stream);
    //
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.insertChild(ASTNode node, int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(debugMode)
      stream.println(ind(2) + "debugNodeAttachment(node);");
    stream.println(ind(2) + "if(children == null) {");
    stream.println(ind(3) + "children = new ASTNode[i + 1];");
    stream.println(ind(3) + "children[i] = node;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild1(stream);
    //
    stream.println(ind(2) + "} else {");
    stream.println(ind(3) + "ASTNode c[] = new ASTNode[children.length + 1];");
    stream.println(ind(3) + "System.arraycopy(children, 0, c, 0, i);");
    stream.println(ind(3) + "c[i] = node;");
    stream.println(ind(3) + "if(i < children.length)");
    stream.println(ind(4) + "System.arraycopy(children, i, c, i+1, children.length-i);");
    stream.println(ind(3) + "children = c;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild2(stream);
    //
    stream.println(ind(2) + "}");
    stream.println(ind(2) + "numChildren++;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild3(stream);
    //
    stream.println(ind(2) + "if(node != null) { node.setParent(this); node.childIndex = i; }");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeInsertChild4(stream);
    //
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.removeChild(int i) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    stream.println(ind(2) + "if(children != null) {");
    stream.println(ind(3) + "ASTNode child = (ASTNode)children[i];");
    stream.println(ind(3) + "if(child != null) {");
    stream.println(ind(4) + "child.setParent(null);");
    stream.println(ind(4) + "child.childIndex = -1;");
    stream.println(ind(3) + "}");
    stream.println(ind(3) + "System.arraycopy(children, i+1, children, i, children.length-i-1);");
    stream.println(ind(3) + "numChildren--;");
    // ES_2011-09-20: Code generation for incremental evaluation, ast change
    if (ASTNode.incremental) jjtGenIncrementalASTChangeRemoveChild(stream);
    //
    stream.println(ind(2) + "}");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public ASTNode ASTNode.getParent() {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(rewriteEnabled) {
      stream.println(ind(2) + "if(parent != null && ((ASTNode)parent).is$Final() != is$Final()) {");
      stream.println(ind(3) + "state().boundariesCrossed++;");
      stream.println(ind(2) + "}");
    }
    // ES_2011-09-20: Code generation for incremental evaluation, track getParent
    if (ASTNode.incremental) jjtGenIncrementalTrackGetParent(stream);
    //
    stream.println(ind(2) + "return (ASTNode)parent;");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.println(ind + "public void ASTNode.setParent(ASTNode node) {");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    stream.println(ind(2) + "parent = node;");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.println(ind + "}");

    if(!jjtree) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode ASTNode.parent;");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "protected ASTNode[] ASTNode.children;");
    }
    if(debugMode) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "protected boolean ASTNode.debugNodeAttachmentIsRoot() { return false; }");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "private static void ASTNode.debugNodeAttachment(ASTNode node) {");
      stream.println(ind(2) + "if(node == null) throw new RuntimeException(\"Trying to assign null to a tree child node\");");
      stream.println(ind(2) + "while(node != null && !node.debugNodeAttachmentIsRoot()) {");
      if(rewriteEnabled)
        stream.println(ind(3) + "if(node.in$Circle()) return;");
      stream.println(ind(3) + "ASTNode parent = (ASTNode)node.parent;");
      stream.println(ind(3) + "if(parent != null && parent.getIndexOfChild(node) == -1) return;");
      stream.println(ind(3) + "node = parent;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "if(node == null) return;");
      stream.println(ind(2) + "throw new RuntimeException(\"Trying to insert the same tree at multiple tree locations\");");
      stream.println(ind + "}");
    }
  }


  // ES_2011-09-20: Code generation for incremental evaluation, tracking getChild
  public void ASTDecl.jjtGenIncrementalTrackGetChild(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler[i] == null) {");
      stream.println(ind(3) +   "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler[i]);");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getChild_handler);");  
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (child != null)");
      stream.println(ind(3) + "  state().addHandlerDepTo(child.handler);");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking getParent
  public void ASTDecl.jjtGenIncrementalTrackGetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(getParent_handler);");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "if (parent != null)");
      stream.println(ind(3) +   "state().addHandlerDepTo(((ASTNode)parent).handler);");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, tracking numChildren
  public void ASTDecl.jjtGenIncrementalTrackNumChild(PrintWriter stream) {  
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "state().addHandlerDepTo(numChildren_handler);");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "state().addHandlerDepTo(handler);");
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set parent
  public void ASTDecl.jjtGenIncrementalSetParent(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "getParent_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "handler.notifyDependencies();");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 1
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) 
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i + 1];");
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 2
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler != null) {");
      stream.println(ind(3) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[i << 1];");
      stream.println(ind(3) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
      stream.println(ind(3) +   "getChild_handler = h;");
      stream.println(ind(2) + "}");
      stream.println(ind(2) + "numChildren_handler.notifyDependencies();");        
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "numChildren_handler.notifyDependencies();");        
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 3
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild3(PrintWriter stream) {
    stream.println(ind(2) + "if (children[i] != null) {");
    stream.println(ind(3) +   "children[i].notifyForRemove();");
    stream.println(ind(2) + "}");
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, set child 4
  public void ASTDecl.jjtGenIncrementalASTChangeSetChild4(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (!childIsNTA(i)) {");
      stream.println(ind(3) +   "for (int k = 0; k < children.length; k++) {");
      stream.println(ind(4) +     "if (getChild_handler[k] != null && !childIsNTA(k)) {");
      stream.println(ind(5) +       "getChild_handler[k].notifyDependencies();");
      stream.println(ind(4) +     "}");
      stream.println(ind(3) +   "}");	
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "if (!childIsNTA(i)) {");
      stream.println(ind(3) +   "getChild_handler.notifyDependencies();");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "handler.notifyDependencies();");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 1
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild1(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "getChild_handler = new ASTNode$DepGraphNode[i + 1];");
      stream.println(ind(3) + "getChild_handler[i] = new ASTNode$DepGraphNode(this, \"getChild\", new Integer(i));");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 2
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild2(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "if (getChild_handler != null) {");
      stream.println(ind(3) +   "ASTNode$DepGraphNode h[] = new ASTNode$DepGraphNode[i << 1];");
      stream.println(ind(3) +   "System.arraycopy(getChild_handler, 0, h, 0, getChild_handler.length);");
      stream.println(ind(3) +   "if (i < getChild_handler.length) {");
      stream.println(ind(4) +     "System.arraycopy(getChild_handler, i, h, i+1, getChild_handler.length);");
      stream.println(ind(3) +   "}");
      stream.println(ind(3) +   "getChild_handler = h;");
      stream.println(ind(2) + "}");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 3
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild3(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr)
      stream.println(ind(2) + "numChildren_handler.notifyDependencies();");
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, insert child 4
  public void ASTDecl.jjtGenIncrementalASTChangeInsertChild4(PrintWriter stream) {
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(2) + "for (int k = 0; k < children.length; k++) {");
      stream.println(ind(3) +   "if (getChild_handler[k] != null) {");
      stream.println(ind(4) +     "getChild_handler[k].notifyDependencies();");
      stream.println(ind(3) +   "}");
      stream.println(ind(2) + "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(2) + "getChild_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "handler.notifyDependencies();");
    }
  }
  // ES_2011-09-20: Code generation for incremental evaluation, modifying tree, remove child 1
  public void ASTDecl.jjtGenIncrementalASTChangeRemoveChild(PrintWriter stream) {
    stream.println(ind(3) + "child.notifyForRemove();");
    if (ASTNode.incrementalLevelParam) {
      stream.println(ind(3) + "if (getChild_handler != null) {");
      stream.println(ind(4) +   "if (getChild_handler[i] != null) {");
      stream.println(ind(5) +     "getChild_handler[i].notifyDependencies();");
      stream.println(ind(5) +     "getChild_handler[i] = null;");
      stream.println(ind(4) +   "}");
      stream.println(ind(4) +   "System.arraycopy(getChild_handler, i+1, " + 
          "getChild_handler, i, getChild_handler.length-i-1);");
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "for (int k = 0; k < children.length; k++) {");
      stream.println(ind(4) +   "if (getChild_handler[k] != null) {");
      stream.println(ind(5) +     "getChild_handler[k].notifyDependencies();");
      stream.println(ind(4) +   "}");
      stream.println(ind(3) + "}");
    }
    if (ASTNode.incrementalLevelAttr) {
      stream.println(ind(3) + "getChild_handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(3) + "handler.notifyDependencies();");
    }
  }

  public void ASTDecl.jjtGenFlushCache(PrintWriter stream) {
    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel low-level");
    stream.println(ind + " */");
    stream.print(ind + "public void flushCache() {\n");
    if(ASTNode.block) stream.print(ASTNode.blockBegin);
    if(!name().equals("ASTNode"))
      stream.print(ind(2) + "super.flushCache();\n");
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq equ = getSynEq(k);
      AttrDecl attr = equ.decl();
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.print(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.print(u);
    }
    // ES_2011-09-20: Code generation for incremental evaluation, flush cache
    if (ASTNode.incremental) jjtGenIncrementalFlushCache(stream);
    //
    stream.print(flushCollectionCacheString());
    if(ASTNode.block) stream.print(ASTNode.blockEnd);

    stream.print(ind + "}\n");

    stream.println(ind + "/**");
    stream.println(ind + " * @apilevel internal");
    stream.println(ind + " */");
    stream.print(ind + "public void flushCollectionCache() {\n");
    if(!name().equals("ASTNode"))
      stream.print(ind(2) + "super.flushCollectionCache();\n");
    stream.print(flushCollectionCacheString());
    stream.print(ind + "}\n");

  }

  // ES_2011-09-20: Code generation for incremental evaluation, flush cache
  public void ASTDecl.jjtGenIncrementalFlushCache(PrintWriter stream) {
    if (ASTNode.incrementalLevelNode) {
      stream.println(ind(2) + "handler.notifyDependencies();");
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      // Collect attributes
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
        AttrDecl attr = getSynEq(k).decl();
        if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
        AttrDecl attr = getInhDecl(k);
        if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      // Generate attribute code
      for (Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        stream.println(ind(2) + "if (" + attr.attributeSignature() + "_handler != null) {");
        if (attr.getNumParameter() == 0) {
          stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
        } else {
          if (ASTNode.incrementalLevelParam) {
            stream.println(ind(3) + "for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                          "_handler.keySet().iterator(); itr.hasNext();) {");
            stream.println(ind(4) +   "Object key = itr.next();");
            stream.println(ind(4) +   "ASTNode$DepGraphNode handler = (ASTNode$DepGraphNode)" + 
                                          attr.attributeSignature() + "_handler.get(key);");
            stream.println(ind(4) +   "handler.notifyDependencies();");
            stream.println(ind(3) + "}");
          }
          if (ASTNode.incrementalLevelAttr) {
            stream.println(ind(3) + attr.attributeSignature() + "_handler.notifyDependencies();");
          }
        }
        stream.println(ind(2) + "}");
      }
    }
  }

  public void ASTDecl.jjtGenCloneNode(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    if(j2me) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.print(ind + "public void init$copy(Object o) {\n");
      stream.print(ind(2) + name() + " node = (" + name() + ")o;\n");
      for(Iterator iter = getClassBodyDeclsItr(); iter.hasNext(); ) {
        ClassBodyObject o = (ClassBodyObject)iter.next();
        jrag.AST.SimpleNode n = o.node;
        if(n instanceof jrag.AST.ASTAspectFieldDeclaration) {
          jrag.AST.Token t2 = ((jrag.AST.SimpleNode)n.jjtGetChild(1)).firstToken;
          String name = t2.image;
          StringBuffer buf = new StringBuffer();
          n.unparseClassBodyDeclaration(buf, name(), aspectJ);
          String field = buf.toString();
          if(field.indexOf("static") == -1 && field.indexOf("final") == -1)
            stream.print(ind(2) + "node." + name + " = " + name + ";\n");
        }
      }

      if(name().equals("ASTNode")) {
        stream.print(ind(2) + "if(children != null) {\n");
        stream.print(ind(3) + "node.children = new ASTNode[children.length];\n");
        stream.print(ind(3) + "for(int i = 0; i < children.length; i++)\n");
        stream.print(ind(4) + "node.children[i] = children[i];\n");
        stream.print(ind(2) + "}\n");
      }
      else {
        stream.print(ind(2) + "super.init$copy(o);\n");
      }

    }
    else if(ASTNode.java5) {
      // covariant return type when using Java 5
      String name = name();
      if(name().equals("Opt") || name().equals("List") || name().equals("ASTNode"))
        name = name + "<T>";
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ASTNode.suppressWarnings() + ind + "public " + name + " clone() throws CloneNotSupportedException {");
    }
    else {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ASTNode.suppressWarnings() + ind + "public Object clone() throws CloneNotSupportedException {");
    }
    if(ASTNode.block) stream.print(ASTNode.blockBegin);

    if(!j2me)
      stream.print(ind(2) + name() + " node = (" + name() + ")super.clone();\n");

    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq equ = getSynEq(k);
      AttrDecl attr = equ.decl();
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      String u = attr.resetVisit() + attr.resetCache();
      u = u.replaceAll("#NAME#", "node." + attr.attributeSignature());
      stream.print(u);
    }

    if(ASTNode.rewriteEnabled) {
      stream.print(ind(2) + "node.in$Circle(false);\n");
      if(ASTNode.stagedRewrites)
        stream.print(ind(2) + "node.is$Final(0);\n");
      else
        stream.print(ind(2) + "node.is$Final(false);\n");
    }

    // I'd like to set the parent to null, but this would change the interface of fullCopy,
    // and existing applications might depend on the copy to still be parented by the original
    // AST. So I don't do it. Yet. 20100416/GH.
    // stream.print(ind(2) + "node.parent = null;\n");

    if(!j2me)
      stream.print(ind(2) + "return node;\n");
    if(ASTNode.block) stream.print(ASTNode.blockEnd);
    stream.print(ind + "}\n");

    if(!hasAbstract()) {
      String copyBody;
      if(j2me) {
        copyBody =
          ind(3) + "#CLASS# node = new #CLASS#();\n" +
          ind(3) + "this.init$copy(node);\n" +
          ind(3) + "return node;\n";
      }
      else {
        copyBody =
          ind(3) + "try {\n" +
          ind(4) + "#CLASS# node = (#CLASS#)clone();\n" +
          ind(4) + "if(children != null) node.children = (ASTNode[])children.clone();\n" +
          ind(4) + "return node;\n" +
          ind(3) + "} catch (CloneNotSupportedException e) {\n" +
          ind(3) + "}\n" +
          ind(3) + "System.err.println(\"Error: Could not clone node of type \" + getClass().getName() + \"!\");\n" +
          ind(3) + "return null;\n";
      }

      String s =
        ind + "/**\n" +
        ind + " * @apilevel internal\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #RETURN# copy() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        copyBody +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #RETURN# fullCopy() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "#ID# res = (#ID#)copy();\n" +
        ind(2) + "for(int i = 0; i < getNumChildNoTransform(); i++) {\n" + 
        ind(3) + "ASTNode node = getChildNoTransform(i);\n" +
        ind(3) + "if(node != null) node = node.fullCopy();\n" +
        ind(3) + "res.setChild(node, i);\n" +
        ind(2) + "}\n" +
        ind(2) + "return res;\n    }\n" +
        (ASTNode.block ? ASTNode.blockEnd : "");

      String returnName = name();
      if(name().equals("Opt") || name().equals("List") || name().equals("ASTNode"))
        returnName = returnName + "<T>";
      s = s.replaceAll("#RETURN#", ASTNode.java5 ? returnName : "ASTNode");
      s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
      s = s.replaceAll("#CLASS#", name());
      s = s.replaceAll("#ID#", name());
      stream.print(s);
    }
  }

  public void ASTDecl.jjtGenCheckTreeStructure(PrintWriter stream) {
    stream.println(ind + "public void " + name() + ".jjtAddChild(Node n, int i) {");
    stream.println(ind(2) + "checkChild(n, i);");
    if(name().equals("ASTNode")) {
      stream.println(ind(2) + "if(i >= numChildren) numChildren = i+1;");
    }
    stream.println(ind(2) + "super.jjtAddChild(n, i);");
    stream.println("}\n");
    if(name().equals("Opt")) {
      stream.println(ind + "public void Opt.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(i > 0) throw new Error(\"Optional nodes can only have one child\");");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"Node type must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else if(name().equals("List")) {
      stream.println(ind + "public void List.checkChild(Node n, int i) {");
      stream.println(ind(2) + "if(!(n instanceof ASTNode)) throw new Error(\"The node type of child \" + i + \" must be an instance of ASTNode\");");
      stream.println(ind + "}\n");
    }
    else {
      int j = 0;
      stream.println(ind + "public void " + name() + ".checkChild(Node n, int i) {");
      for(Iterator iter = getComponents(); iter.hasNext(); ) {
        Components c = (Components)iter.next();
        c.jjtGenCheckTreeStructure(stream, j);
        if(!(c instanceof TokenComponent)) {
          j++;
        }
      }
      stream.println(ind + "}\n");
    }
  }
  public void Components.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
  }
  public void ListComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + ") {");
    stream.println(
        ind(3) + "if(!(n instanceof List))\n" + 
        ind(4) + "throw new Error(\"Child number " + j + " of " + hostClass().name() + 
        " has the type \" + n.getClass().getName() + \" which is not an instance of List\");");
    stream.println(ind(3) + "for(int k = 0; k < ((List)n).getNumChildNoTransform(); k++)");
    stream.println(
        ind(3) + "if(!(((List)n).getChildNoTransform(k) instanceof " + type() + "))\n" + 
        ind(4) + "throw new Error(\"Child number \" + k + \" in " + name() + "List" + 
        " has the type \" + ((List)n).getChildNoTransform(k).getClass().getName() + \" which is not an instance of " +
        type() + "\");");
    stream.println(ind(2) + "}");
  }
  public void OptionalComponent.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + ") {");
    stream.println(
        ind(3) + "if(!(n instanceof Opt))\n" + 
        ind(4) + "throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of Opt\");");
    stream.println(
        ind(3) + "if(((Opt)n).getNumChildNoTransform() != 0 && !(((Opt)n).getChildNoTransform(0) instanceof " + type() + "))\n" +
        ind(4) + "throw new Error(\"Optional " + name() + 
        " has the type \" + ((Opt)n).getChildNoTransform(0).getClass().getName() + \" which is not an instance of " +
        type() + "\");");
    stream.println(ind(2) + "}");
  }
  public void AggregateComponents.jjtGenCheckTreeStructure(PrintWriter stream, int j) {
    stream.println(ind(2) + "if(i == " + j + " && !(n instanceof " + type() + ")) " + 
        " throw new Error(\"Child number " + j + " of " + hostClass().name() +
        " has the type \" + n.getClass().getName() + \" which is not an instance of " + type() + "\");");
  }

  public void ASTDecl.jjtGenDumpTree(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    StringBuffer sb = new StringBuffer();
    sb.append(ind + "public void " + name() + ".dumpTree(String indent, java.io.PrintStream pStream) {\n" + 
        ind(2) + "pStream.println(indent + \"" + name() + "\"");
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof TokenComponent) {
        TokenComponent t = (TokenComponent)c;
        String id = t.getTokenId().getID();
        sb.append("+ \"\\\"\" + get" + id + "() + \"\\\"\"");
      }
    }
    sb.append(");\n        String childIndent = indent + \"  \";\n" + 
        ind(2) + "for(int i = 0; i < getNumChild(); i++)\n" + 
        ind(3) + "getChild(i).dumpTree(childIndent, pStream);\n" +
        ind + "}\n");
    stream.println(sb.toString());
  }

  public void ASTDecl.jjtGenVisitor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    stream.println(ind + "public Object " + name() + ".jjtAccept(" + parserName + "Visitor visitor, Object data) {\n" +
        ind(2) + "return visitor.visit(this, data);\n" + 
        ind + "}\n");
  }

  public void ASTDecl.jjtGenConstructor(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String finalInit = "";
    if(rewriteEnabled && isRootNode()) {
      if(ASTNode.stagedRewrites)
        finalInit = ind(2) + "is$Final(state().rewritePhase);\n";
      else
        finalInit = ind(2) + "is$Final(true);\n";
    }
    String s;
    if(jjtree) {
      s = ind + "public #ID#.#ID#(int i) {\n" +
        ind(2) + "super(i);\n" + finalInit +
        ind + "}\n" +
        ind + "public #ID#.#ID#(" + parserName + " p, int i) {\n" +
        ind(2) + "this(i);\n" +
        ind(2) + "parser = p;\n" + finalInit +
        ind + "}\n" +
        ind + "public #ID#.#ID#() {\n" + 
        ind(2) + "this(0);\n" + 
        "#NTA#";
    }
    else {
      s = ind + "public #ID#.#ID#() {\n" + // Lgg till null fr agg, tom lista fr list, false fr opt
        ind(2) + "super();\n" + 
        "#NTA#";
    }
    String t = new String();
    int i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponentsNTA) {
        //t = t + ind(2) + "setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof OptionalComponentNTA) {
        //t = t + ind(2) + "setChild(new Opt(), " + String.valueOf(i) + ");\n";
        i++;
      }
      if(c instanceof AggregateComponentsNTA) {
        //t = t + ind(2) + "setChild(null, " + String.valueOf(i) + ");\n";
        i++;
      }
    }
    s = s.replaceAll("#ID#", name());
    s = s.replaceAll("#NTA#", t);
    stream.println(s);
    // Initialize node
    i = 0;
    for(Iterator iter = getComponents(); iter.hasNext(); ) {
      Components c = (Components)iter.next();
      if(c instanceof ListComponents) {
        stream.println(ind(2) + "setChild(new List(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof OptionalComponent) {
        stream.println(ind(2) + "setChild(new Opt(), " + String.valueOf(i) + ");");
        i++;
      }
      else if(c instanceof AggregateComponents) {
        //stream.println(ind(2) + "setChild(null, " + String.valueOf(i) + ");");
        i++;
      }
    }
    stream.println(finalInit);
    stream.println(ind + "}\n");

    if(numNonNTAComponents() != 0) {
      stream.print(buildingConstructor());
      if(ASTNode.beaver)
        stream.print(buildingSymbolConstructor());
    }

    if(name().equals("Opt")) {
      if(ASTNode.java5)
        stream.println(ind + "public Opt.Opt(T opt) {");
      else
        stream.println(ind + "public Opt.Opt(ASTNode opt) {");
      stream.println(ind(2) + "setChild(opt, 0);");
      stream.println(ind + "}\n");
    }

  }

  public void ASTDecl.jjtGen(PrintWriter stream, String parserName, boolean jjtree, boolean rewriteEnabled) {
    String s;

    jjtGenConstructor(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenCloneNode(stream, parserName, jjtree, rewriteEnabled);
    //jjtGenFlushCache(stream);
    if(jjtree) {
      jjtGenDumpTree(stream, parserName, jjtree, rewriteEnabled);
      jjtGenVisitor(stream, parserName, jjtree, rewriteEnabled);
      try {
        jjtGenCheckTreeStructure(stream);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }

    // Generate code common for all nodes by adding them to ASTNode
    if(name().equals("ASTNode")) {
      jjtGenASTNode(stream, parserName, jjtree, rewriteEnabled);
      env().genRewriteOrderChecks(stream);
      env().genReset(stream);
      if(ASTNode.java5) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public java.util.Iterator<T> ASTNode.iterator() {");
        if(ASTNode.block) stream.append(ASTNode.blockBegin);
        stream.println(ind + "return new java.util.Iterator<T>() {");
        stream.println(ind(3) + "private int counter = 0;");
        stream.println(ind(3) + "public boolean hasNext() {");
        stream.println(ind(4) + "return counter < getNumChild();");
        stream.println(ind(3) + "}");
        stream.println(ind(3) + "@SuppressWarnings(\"unchecked\") public T next() {");
        stream.println(ind(4) + "if(hasNext())");
        stream.println(ind(5) + "return (T)getChild(counter++);");
        stream.println(ind(4) + "else");
        stream.println(ind(5) + "return null;");
        stream.println(ind(3) + "}");
        stream.println(ind(3) + "public void remove() {");
        stream.println(ind(4) + "throw new UnsupportedOperationException();");
        stream.println(ind(3) + "}");
        stream.println(ind + "};");
        if(ASTNode.block) stream.append(ASTNode.blockEnd);
        stream.println(ind + "}");
      }
      
    }
    else if(name().equals("List")) {
      if(ASTNode.java5)
        stream.println(ind + "public List<T> List.add(T node) {");
      else
        stream.println(ind + "public List List.add(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      if(debugMode) {
        stream.println(ind(2) + "if(node instanceof List)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type List\");");
        stream.println(ind(2) + "if(node instanceof Opt)");
        stream.println(ind(3) + "throw new RuntimeException(\"Lists can not have children of type Opt\");");
      }
      stream.println(ind(2) + "addChild(node);");
      stream.println(ind(2) + "return this;");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}\n");
      stream.println(ind + "public void List.insertChild(ASTNode node, int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println(ind(2) + "list$touched = true;");
      stream.println(ind(2) + "super.insertChild(node, i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      if(ASTNode.java5)
        stream.println(ind + "public void List.addChild(T node) {");
      else
        stream.println(ind + "public void List.addChild(ASTNode node) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println(ind(2) + "list$touched = true;");
      stream.println(ind(2) + "super.addChild(node);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel low-level");
      stream.println(ind + " */");
      stream.println(ind + "public void List.removeChild(int i) {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println(ind(2) + "list$touched = true;");
      stream.println(ind(2) + "super.removeChild(i);");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "public int List.getNumChild() {");
      if(ASTNode.block) stream.append(ASTNode.blockBegin);
      stream.println(ind(2) + "if(list$touched) {");
      stream.println(ind(3) + "for(int i = 0; i < getNumChildNoTransform(); i++)");
      stream.println(ind(4) + "getChild(i);");
      stream.println(ind(4) + "list$touched = false;");
      stream.println(ind(3) + "}");
      stream.println(ind(3) + "return getNumChildNoTransform();");
      if(ASTNode.block) stream.append(ASTNode.blockEnd);
      stream.println(ind + "}");
      stream.println(ind + "private boolean List.list$touched = true;");
    }
    else if(name().equals("Opt")) {
      // do not override getNumChild with implementation below
    }
    else {

      if(jjtree) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "public int " + name() + ".getNumChild() {");
        // ES_2011-09-20: Code generation for incremental evaluation, tracking numChild
        if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
        // 
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      else {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel low-level");
        stream.println(ind + " */");
        stream.println(ind + "protected int " +name() + ".numChildren() {");
        // ES_2011-09-20: Code generation for incremental evaluation, tracking numChild
        if (ASTNode.incremental) jjtGenIncrementalTrackNumChild(stream);
        // 
        stream.println(ind(2) + "return " + numRegularChildren() + ";");
        stream.println(ind + "}");
      }
      if(debugMode && isRootNode()) {
        stream.println(ind + "/**");
        stream.println(ind + " * @apilevel internal");
        stream.println(ind + " */");
        stream.println(ind + "protected boolean " + name() + ".debugNodeAttachmentIsRoot() { return true; }");
      }
    }
    if(rewriteEnabled) {
      stream.println(ind + "/**");
      stream.println(ind + " * @apilevel internal");
      stream.println(ind + " */");
      stream.println(ind + "public boolean " + name() + ".mayHaveRewrite() {");
      if(name().equals("List"))
        stream.println(ind(2) + "return true;");
      else if(!hasRewrites())
        stream.println(ind(2) + "return false;");
      else if(!stagedRewrites || rewriteWithNoPhaseCondition())
        stream.println(ind(2) + "return true;");
      else {
        for(Iterator iter = rewritePhaseConditions().iterator(); iter.hasNext(); ) {
          String condition = (String)iter.next();
          stream.println(ind(2) + "if(" + condition + ") return true;");
        }
        stream.println(ind(2) + "return false;");
      }
      stream.println(ind + "}");
    }

    // ES_2011-09-19: Code generation for incremental evaluation
    if (ASTNode.incremental) jjtGenIncremental(stream);
  }

  // ES_2011-09-20: Code generation for incremental evaluation
  public void ASTDecl.jjtGenIncremental(PrintWriter stream) {
    jjtGenIncrementalHandlers(stream);
    jjtGenIncrementalNTAChildCheck(stream);
    jjtGenIncrementalReactToChange(stream);
    jjtGenIncrementalReactToASTChange(stream);
    if (ASTNode.incrementalDebug) jjtGenIncrementalDebug(stream);
  }

  // ES_2011-09-20: Code generation for incremental evaluation, initialization of handlers
  public void ASTDecl.jjtGenIncrementalHandlers(PrintWriter stream) {
    // level node: one handler per node
    if (ASTNode.incrementalLevelNode) {
      if (name().equals("ASTNode")) {
        stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.handler = " + 
            "new ASTNode$DepGraphNode(this);");                    
      }
    } 
    // level param, attr: at least one handler per attribute
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      // handlers specific for ASTNode
      if (name().equals("ASTNode")) {
        if (ASTNode.incrementalLevelParam) {
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getParent_handler = " + 
              "new ASTNode$DepGraphNode(this, \"getParent\", null);");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.numChildren_handler = " +
              "new ASTNode$DepGraphNode(this, \"numChildren\", null);");
          stream.println(ind + "protected ASTNode$DepGraphNode[] ASTNode.getChild_handler;");
        } 
        if (ASTNode.incrementalLevelAttr) {
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getParent_handler = " + 
              "new ASTNode$DepGraphNode(this, \"getParent\");");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.numChildren_handler = " +
              "new ASTNode$DepGraphNode(this, \"numChildren\");");
          stream.println(ind + "protected ASTNode$DepGraphNode ASTNode.getChild_handler = " +
              "new ASTNode$DepGraphNode(this, \"getChild\");");
        }
      }
      // collect attributes
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynDecl(); k++) {
 	      AttrDecl attr = getSynDecl(k);
      	if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
    	for(int k = 0; k < getNumInhDecl(); k++) {
    	  AttrDecl attr = getInhDecl(k);
    	  if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for (int k = 0; k < getNumCollDecl(); k++) {
    	  CollDecl attr = getCollDecl(k);
        list.add(attr);      
      }
      // attribute code 
      for (Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (ASTNode.incrementalLevelParam) {
          // level param: check if this is a parameterized attribute
    	    if (attr.getNumParameter() > 0) {
    	      stream.println(ind + "protected java.util.Map " + name() + "." + attr.attributeSignature() + 
                  "_handler = new java.util.HashMap(4);");
    	    } else {
            stream.println("  protected ASTNode$DepGraphNode " + name() + "." + 
                  attr.attributeSignature() + "_handler;");
          }
        }
        // level attr: Add one handler per attribute
        if (ASTNode.incrementalLevelAttr) {
  		      stream.println(ind + "protected ASTNode$DepGraphNode " + name() + "." + 
                  attr.attributeSignature() + "_handler;");            
        }
      }
    }
  }

  // ES_2011-09-23: Code generation for incremental evaluation, check if NTA child
  public void ASTDecl.jjtGenIncrementalNTAChildCheck(PrintWriter stream) {
    // collect attributes
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynDecl(); k++) {
      AttrDecl attr = getSynDecl(k);
    	if (attr.isNTA()) 
        list.add(attr);
    }
  	for(int k = 0; k < getNumInhDecl(); k++) {
  	  AttrDecl attr = getInhDecl(k);
  	  if (attr.isNTA()) 
        list.add(attr);
    }
    // method signature
    stream.println(ind + "protected boolean " + name() + ".childIsNTA(int index) {");
    // attribute code
    boolean first = true;
    for (Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      if (first) {
        stream.print(ind(2) + "if (");
        first = false;
      } else stream.print(" || ");
      stream.print("index == " +  attr.indexNTAchild());
    }
    if (!first) {
      stream.println(")");
      stream.println(ind(3) + "return true;");
    }
    // method end
    if (name().equals("ASTNode"))
      stream.println(ind(2) + "return false;");
    else stream.println(ind(2) + "return super.childIsNTA(index);");
    stream.println(ind + "}");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, react to change
  public void ASTDecl.jjtGenIncrementalReactToChange(PrintWriter stream) {
    // Method: reactToDependencyChange
    if (ASTNode.incrementalLevelParam)
      stream.println("    public void " + name() + ".reactToDependencyChange(String attrID, Object _parameters) {");      
    if (ASTNode.incrementalLevelAttr) 
      stream.println("    public void " + name() + ".reactToDependencyChange(String attrID) {");      
    if (ASTNode.incrementalLevelNode) 
      stream.println("    public void " + name() + ".reactToDependencyChange() {");      

    if (ASTNode.incrementalChangeFlush) 
      jjtGenIncrementalChangeFlush(stream);

    // super class if not ASTNode
    if (!name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam)
        stream.println("      super.reactToDependencyChange(attrID, _parameters);");      
      if (ASTNode.incrementalLevelAttr) 
        stream.println("      super.reactToDependencyChange(attrID);");      
      if (ASTNode.incrementalLevelNode) 
        stream.println("      super.reactToDependencyChange();");      
    }
    // end method
    stream.println("    }");
  }

  // ES_2011-09-20: Code generation for incremental evaluation, change strategy: flush
  public void ASTDecl.jjtGenIncrementalChangeFlush(PrintWriter stream) {

    // ES_TODO Add change propagation !

    // old code for handling of rewritten children in case of a flush
    //stream.println("      if (attrID.equals(\"getChild\")) {");
    //stream.println("        int i = (Integer)_parameters;");
    //stream.println("        if (init_children != null && init_children[i] != null) {");
    //stream.println("          getChild(i).notifyForRemove();");
    //stream.println("          children[i] = init_children[i];");
    //stream.println("          init_children[i] = null;");
    //stream.println("        }");
    //stream.println("      }");

    // Collect attributes: syn then inh
    ArrayList list = new ArrayList();
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrDecl attr = getSynEq(k).decl();
      if (attr.getLazy() || attr.isCircular()) 
        list.add(attr);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      AttrDecl attr = getInhDecl(k);
      if (attr.getLazy() || attr.isCircular()) 
        list.add(attr);
    }
    // Add attribute code: flush attributes
    boolean first = true;
    for(Iterator itr = list.iterator(); itr.hasNext();) {
      AttrDecl attr = (AttrDecl)itr.next();
      // start match attribute statement
      if (ASTNode.incrementalLevelParam)
        stream.println("     " + (first ? "" : "else ") + "if (attrID.equals(\"" + attr.attributeSignature() + "\")" + 
            (attr.getNumParameter() > 0 ? " && " + attr.attributeSignature() + "_values != null" : "") + " && " +
            attr.attributeSignature() + "_values.contains(_parameters)) {");
      if (ASTNode.incrementalLevelAttr) 
        stream.println("     " + (first ? "" : "else ") + "if (attrID.equals(\"" + attr.attributeSignature() + "\") && " +
            attr.attributeSignature() + "_computed) {");
      if (ASTNode.incrementalLevelNode)
        stream.println("     if (" + attr.attributeSignature() + (attr.getNumParameter() > 0 ? ":values != null" : "_computed") + ") {"); 
      // handle parameterized attributes
      if (attr.getNumParameter() > 0) {
        if (ASTNode.incrementalLevelParam) {
          stream.println("       " + attr.attributeSignature() + "_values.remove(_parameters);"); 
        } else {
          String u = attr.resetVisit() + attr.resetCache();
          u = u.replaceAll("#NAME#", attr.attributeSignature());
          stream.print(u);              
        }
      } else {
        // handle NTAs
        if (attr.isNTA()) {
          stream.println("       " + attr.attributeSignature() + "_value.notifyForRemove();");
        }
        String u = attr.resetVisit() + attr.resetCache();
        u = u.replaceAll("#NAME#", attr.attributeSignature());
        stream.print(u);
      }


      // end match statement
      stream.println("     }");
      first = false;
    }
  }

  // ES_2011-09-20: Code generation for incremental evaluation, 
  public void ASTDecl.jjtGenIncrementalReactToASTChange(PrintWriter stream) {

    // Method: notifyForRemove
    stream.println("    public void " + name() + ".notifyForRemove() {");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam) {
        stream.println("      getParent_handler.notifyDependencies();");
        stream.println("      numChildren_handler.notifyDependencies();");
        stream.println("      for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println("        if (getChild_handler[i].hasDependants()) {");
        stream.println("          getChildNoTransform(i).notifyForRemove();");
        stream.println("          getChild_handler[i].notifyDependencies();");
        stream.println("        }");
        stream.println("      }");
      }
      if (ASTNode.incrementalLevelAttr) {
        stream.println("      getParent_handler.notifyDependencies();");
        stream.println("      numChildren_handler.notifyDependencies();");
        stream.println("      if (getChild_handler.hasDependants()) {");
        stream.println("        getChild_handler.notifyDependencies();");
        stream.println("        for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println("          getChildNoTransform(i).notifyForRemove();");
        stream.println("        }");
        stream.println("      }");
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println("      handler.notifyDependencies();");
        stream.println("      for (int i = 0; i < getNumChildNoTransform(); i++) {");
        stream.println("        getChildNoTransform(i).notifyForRemove();");
        stream.println("      }");
      }
    } else {
      stream.println("      super.notifyForRemove();");
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        // tokens
        for (int c = 0; c < getNumComponents(); c++) {
 	    		Components comp = getComponents(c);
 	    		if (comp instanceof TokenComponent) {
	    			stream.println("    get" + ((TokenComponent)comp).getTokenId().getID() + 
                                "_handler.notifyDependencies();");
 	    		}
 	    	}
        // Collect attributes: syn then inh
        ArrayList list = new ArrayList();
        for(int k = 0; k < getNumSynEq(); k++) {
          AttrDecl attr = getSynEq(k).decl();
          if (attr.getLazy() || attr.isCircular()) 
            list.add(attr);
        }
        for(int k = 0; k < getNumInhDecl(); k++) {
          AttrDecl attr = getInhDecl(k);
          if (attr.getLazy() || attr.isCircular()) 
            list.add(attr);
        }
        // Attribute code: propagate change of all cached values being removed
        for(Iterator itr = list.iterator(); itr.hasNext();) {
          AttrDecl attr = (AttrDecl)itr.next();
          if (ASTNode.incrementalLevelParam) {
            if (attr.getNumParameter() > 0) {
      	      stream.println("      for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                    "_handler.values().iterator(); itr.hasNext();) {");
              stream.println("        ASTNode$DepGraphNode h = (ASTNode$DepGraphNode)itr.next();");
              stream.println("        h.notifyDependencies();");
              stream.println("      }");
            } else {
              stream.println("      if (" + attr.attributeSignature() + "_handler != null) {");
              stream.println("        " + attr.attributeSignature() + "_handler.notifyDependencies();");
      	      stream.println("      }");
      	    }
          }
          if (ASTNode.incrementalLevelAttr) {
      	    stream.println("      if (" + attr.attributeSignature() + "_handler != null) {");
      	    stream.println("        " + attr.attributeSignature() + "_handler.notifyDependencies();");
       	    stream.println("      }");
          }
    	  }
      }
    }
    // end method
    stream.println("    }");
  }
  

  // ES_2011-09-20: Debug code generation for incremental evaluation
  public void ASTDecl.jjtGenIncrementalDebug(PrintWriter stream) {
    if (name().equals("ASTNode")) {
      // Relative ID          
      stream.println("    public String ASTNode.relativeNodeID() {");
      stream.println("      ASTNode parent = getParent();");
      stream.println("      StringBuffer buf = new StringBuffer();");
      stream.println("      int index = -1;");
      stream.println("      if (parent != null) {");
      stream.println("        buf.append(parent.relativeNodeID() + \"/\");");
      stream.println("        index = parent.getIndexOfChild(this);");
      stream.println("      }");
      stream.println("      buf.append(getClass().getSimpleName());");
      stream.println("      if (index > -1) {");
      stream.println("        buf.append(\"[\" + index + \"]\");");
      stream.println("      }");
      stream.println("      return buf.toString();");
      stream.println("    }");

      // printParamList
      stream.println("  protected String ASTNode.printParamList(java.util.List paramList) {");
      stream.println("    StringBuffer buf = new StringBuffer();");
      stream.println("    for (java.util.Iterator itr = paramList.iterator(); itr.hasNext();) {");
      stream.println("      Object o = itr.next();");
      stream.println("      if (o instanceof ASTNode) {");
      stream.println("        buf.append(((ASTNode)o).relativeNodeID());");
      stream.println("      } else {");
      stream.println("        buf.append(o.toString());");
      stream.println("      }");
      stream.println("      buf.append(\",\");");
      stream.println("    }");
      stream.println("    return buf.toString();");
      stream.println("  }");

    }
    
    // dumpCachedValues
    stream.println("    public void " + name() + ".dumpCachedValues(java.io.PrintWriter writer) {");
    //stream.println("      for (int k = 0; init_children != null && k < init_children.length; k++) {");
    //stream.println("        if (init_children[k] != null) {");
    //stream.println("          System.out.println(getChildNoTransform(k).relativeNodeID() + " + 
    //                                  "\" rewritten from \" + init_children[k].relativeNodeID());");
    //stream.println("        }");
    //stream.println("      }");
    for(int k = 0; k < getNumSynEq(); k++) {
      AttrEq attrEq = getSynEq(k);
    	AttrDecl attr = attrEq.decl();
      String u = attr.dumpCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.println(u);
    }
    for(int k = 0; k < getNumInhDecl(); k++) {
      InhDecl attr = getInhDecl(k);
      String u = attr.dumpCache();
      u = u.replaceAll("#NAME#", attr.attributeSignature());
      stream.print(u);
    }
    stream.println("        // TODO: dump collection values");
    if (!name().equals("ASTNode")) 
      stream.println("        super.dumpCachedValues(writer);");
    stream.println("    }");          
      
    // dumpDependencies
    stream.println("    public void " + name() + ".dumpDependencies() {");
    if (name().equals("ASTNode")) {
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        stream.println("      getParent_handler.dumpDeps();");
        stream.println("      numChildren_handler.dumpDeps();");
        if (ASTNode.incrementalLevelParam) {
          stream.println("      for (int k = 0; getChild_handler != null && k < getChild_handler.length; k++) {");
          stream.println("        if (getChild_handler[k] != null) {");
          stream.println("          getChild_handler[k].dumpDeps();");
          stream.println("        }");
          stream.println("      }");
        }
        if (ASTNode.incrementalLevelAttr) {
          stream.println("      getChild_handler.dumpDeps();");
        }
      }
      if (ASTNode.incrementalLevelNode) {
        stream.println("      handler.dumpDeps();");
      }
    } else {
      if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
        for (int c = 0; c < getNumComponents(); c++) {
 	    	  Components comp = getComponents(c);
 	  		  if (comp instanceof TokenComponent) {
	  			  stream.println("    get" + ((TokenComponent)comp).getTokenId().getID() + "_handler.dumpDeps();");
 	  		  }
 	  	  }
      }
    }
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr) {
      // Collect attributes
      ArrayList list = new ArrayList();
      for(int k = 0; k < getNumSynEq(); k++) {
 	      AttrDecl attr = getSynEq(k).decl();
 	      if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      for(int k = 0; k < getNumInhDecl(); k++) {
     	  InhDecl attr = getInhDecl(k);
 	      if (attr.getLazy() || attr.isCircular()) 
          list.add(attr);
      }
      // attribute code
      for (Iterator itr = list.iterator(); itr.hasNext();) {
        AttrDecl attr = (AttrDecl)itr.next();
        if (attr.getNumParameter() == 0) {
          stream.println("      if (" + attr.attributeSignature() + "_handler != null) " + 
                                  attr.attributeSignature() + "_handler.dumpDeps();");
        } else {
          if (ASTNode.incrementalLevelParam) {
            stream.println("      if (" + attr.attributeSignature() + "_handler != null) {");
            stream.println("        for (java.util.Iterator itr = " + attr.attributeSignature() + 
                                                    "_handler.keySet().iterator(); itr.hasNext();) {");
            stream.println("          Object key = itr.next();");
            stream.println("          Object value = " + attr.attributeSignature() + "_handler.get(key);");
            stream.println("          ((ASTNode$Handler)value).dumpDeps();");
            stream.println("        }");
            stream.println("      }");
          } 
          if (ASTNode.incrementalLevelAttr) {
            stream.println("      if (" + attr.attributeSignature() + "_handler != null) " + 
                                  attr.attributeSignature() + "_handler.dumpDeps();");            
          }
        }
      }
    }
    stream.println("        // TODO: dump collection values");
    // super call
    if (!name().equals("ASTNode")) {
      stream.println("        super.dumpDependencies();");
    }
    // end method
    stream.println("    }");  
  }

  // ES_2011-09-06: Code generation for incremental evaluation, dependency node class / handler class
  public void Grammar.jjtGenASTNode$DepGraphNode(PrintWriter stream, String parserName) {
    // Class: ASTNode$DepGraphNode
    stream.println("  static public class ASTNode$DepGraphNode {");
    // level: node, attr, param all need a node to store the dependency node in
	  stream.println("    protected ASTNode fNode;");
    // level: param needs both an attr ID and a param ID
    if (ASTNode.incrementalLevelParam) {
	    stream.println("    protected String fAttrID;");
	    stream.println("    protected Object fParams;");
      stream.println("    public ASTNode$DepGraphNode(ASTNode node, String attrID, Object params) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = attrID;");
      stream.println("      fParams = params;");
      stream.println("    }");
    }
    // level: attr also needs an attr ID 
    if (ASTNode.incrementalLevelAttr) {
	    stream.println("    public String fAttrID;");
      stream.println("    public ASTNode$DepGraphNode(ASTNode node, String attrID) {");
      stream.println("      fNode = node;");
      stream.println("      fAttrID = attrID;");
      stream.println("    }");
    }
    // level: node
    if (ASTNode.incrementalLevelNode) {
      stream.println("    public ASTNode$DepGraphNode(ASTNode node) {");
      stream.println("      fNode = node;");
      stream.println("    }");    
    }
    // behavior generic for any kind of dependency region
	  stream.println("    public java.util.HashSet<ASTNode$DepGraphNode> fDependantSet = " +
                   "        new java.util.HashSet<ASTNode$DepGraphNode>();");
    stream.println("    public boolean hasDependants() {");
    stream.println("        return !fDependantSet.isEmpty();");
    stream.println("    }");
    stream.println("    public void addDependant(ASTNode$DepGraphNode node) {");
    stream.println("      if (node != this) {");
    stream.println("        fDependantSet.add(node);");
    stream.println("      }");
    stream.println("    }");
    stream.println("    public void notifyDependencies() {");
    stream.println("      java.util.HashSet<ASTNode$DepGraphNode> l = fDependantSet;");
    stream.println("      fDependantSet = new java.util.HashSet<ASTNode$DepGraphNode>();");
    stream.println("      for (ASTNode$DepGraphNode node : l) {");
    stream.println("        node.dependencyChanged();");
    stream.println("      }");
    stream.println("    }");
    // React to change
    stream.println("    public void dependencyChanged() {");
    if (ASTNode.incrementalLevelParam)
      stream.println("      fNode.reactToDependencyChange(fAttrID, fParams);");
    if (ASTNode.incrementalLevelAttr) 
      stream.println("      fNode.reactToDependencyChange(fAttrID);");
    if (ASTNode.incrementalLevelNode)
      stream.println("      fNode.reactToDependencyChange();");
    stream.println("    }");
    // Debugging methods:
    if (ASTNode.incrementalDebug) {
      stream.println("    public void dumpDeps() {");
      stream.println("      for (ASTNode$DepGraphNode node : fDependantSet) {");
      stream.println("        System.out.println(\"dep(\" + node + \" -> \" + this + \")\");");
      stream.println("      }");
      stream.println("    }");
      stream.println("    public String toString() {");
      if (ASTNode.incrementalLevelParam) 
        stream.println("      return fNode.relativeNodeID() + \"_\" + fAttrID + " +
            "(fParams != null ? (\"[\" + (fParams instanceof ASTNode ? " +
            "((ASTNode)fParams).relativeNodeID() : fParams) + \"]\") : \"\");");
      if (ASTNode.incrementalLevelAttr)
        stream.println("      return fNode.relativeNodeID() + \"_\" + fAttrID;");
      if (ASTNode.incrementalLevelNode)
        stream.println("      return fNode.relativeNodeID();");
      stream.println("    }");
    }
    stream.println("  }"); // End ASTNode$DepGraphNode
  }


  syn boolean ASTDecl.rewriteWithNoPhaseCondition() {
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() == null)
        return true;
      String condition = getRewrite(i).getCondition().unparse();
      if(condition.indexOf("inRewritePhase") == -1 && condition.indexOf("inExactRewritePhase") == -1)
        return true;
    }
    return superClass() instanceof ASTDecl && ((ASTDecl)superClass()).rewriteWithNoPhaseCondition();
  }

  syn java.util.Set ASTDecl.rewritePhaseConditions() {
    java.util.Set set = new java.util.LinkedHashSet();
    Pattern p = Pattern.compile("inRewritePhase\\([\\w\\.]*\\)|inExactRewritePhase\\([\\w\\.]*\\)");
    for(int i = 0; i < getNumRewrite(); i++) {
      if(getRewrite(i).getCondition() != null) {
        String condition = getRewrite(i).getCondition().unparse();
        Matcher m = p.matcher(condition);
        while(m.find()) {
          String match = m.group();
          set.add(match);
        }
      }
    }
    if(superClass() instanceof ASTDecl)
      set.addAll(((ASTDecl)superClass()).rewritePhaseConditions());
    return set;
  }

  public abstract void Components.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl);

  String ListComponents.setNameListComment() {
    return ind + "/**\n" +
      ind + " * Setter for #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNumNameComment() {
    return ind + "/**\n" +
      ind + " * @return number of children in #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNameComment() {
    return ind + "/**\n" +
      ind + " * Getter for child in list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.addNameComment() {
    return ind + "/**\n" +
      ind + " * Add element to list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.setNameComment() {
    return ind + "/**\n" +
      ind + " * Setter for child in list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String ListComponents.getNameListComment() {
    return ind + "/**\n" +
      ind + " * Getter for list #NAME#List\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }


  public void ListComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String s;
    String name = decl.name();
    // Generate getNum- and get-method for the list component
    s = setNameListComment() +
      ind + "public void #HOST#.set#NAME#List(#LISTTYPE# list) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "setChild(list, #INDEX#);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      //ind + "private int #HOST#.getNum#NAME# = 0;\n" +
      getNumNameComment() +
      ind + "public int #HOST#.getNum#NAME#() {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return get#NAME#List().getNumChild();\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      getNameComment() +
      "#ANNOTATIONS#" +
      ind + "public #TYPE# #HOST#.get#NAME#(int i) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return (#TYPE#)get#NAME#List().getChild(i);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      addNameComment() +
      ind + "public void #HOST#.add#NAME#(#TYPE# node) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = (parent == null || state == null) ? get#NAME#ListNoTransform() : get#NAME#List();\n" +
      ind(2) + "list.addChild(node);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      ind + "/**\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n" +
      ind + "public void #HOST#.add#NAME#NoTransform(#TYPE# node) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = get#NAME#ListNoTransform();\n" +
      ind(2) + "list.addChild(node);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node, int i) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "#LISTTYPE# list = get#NAME#List();\n" +
      ind(2) + "list.setChild(node, i);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(ASTNode.java5) {
      s +=
        ind + "/**\n" +
        ind + " * Getter for #NAME# list.\n" +
        ind + " * @apilevel high-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#s() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return get#NAME#List();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#sNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return get#NAME#ListNoTransform();\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    if(!isNTA()) {
      s +=
        getNameListComment() +
        "#ANNOTATIONS#" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#List() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "#LISTTYPE# list = (#LISTTYPE#)getChild(#INDEX#);\n" +
        ind(2) + "list.getNumChild();\n" +
        ind(2) + "return list;\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" + 
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #LISTTYPE# #HOST#.get#NAME#ListNoTransform() {\n" + 
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#LISTTYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#ListChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#LISTTYPE#", ASTNode.java5 ? "List<" + getId().type() + ">" : "List");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }

  String OptionalComponent.setNameOptComment() {
    return ind + "/**\n" +
      ind + " * Setter for #NAME#Opt\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.hasNameComment() {
    return ind + "/**\n" +
      ind + " * Does this node have a #NAME# child?\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.getNameComment() {
    return ind + "/**\n" +
      ind + " * Getter for optional child #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.setNameComment() {
    return ind + "/**\n" +
      ind + " * Setter for optional child #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String OptionalComponent.getNameOptComment() {
    return ind + "/**\n" +
      ind + " * Getter for #NAME#Opt\n" +
      ind + " * @apilevel low-level\n" +
      ind + " */\n";
  }

  public void OptionalComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate has- and get-method for the optional component
    s = setNameOptComment() +
      ind + "public void #HOST#.set#NAME#Opt(#OPTTYPE# opt) {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "setChild(opt, #INDEX#);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      hasNameComment() +
      ind + "public boolean #HOST#.has#NAME#() {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return get#NAME#Opt().getNumChild() != 0;\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" +
      getNameComment() +
      "#ANNOTATIONS#" +
      ind + "public #TYPE# #HOST#.get#NAME#() {\n" +
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "return (#TYPE#)get#NAME#Opt().getChild(0);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n" + 
      setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "get#NAME#Opt().setChild(node, 0);\n" +
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(!isNTA()) {
      s +=
        getNameOptComment() +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#Opt() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChild(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        "#ANNOTATIONS#" +
        ind + "public #OPTTYPE# #HOST#.get#NAME#OptNoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#OPTTYPE#)getChildNoTransform(#INDEX#);\n" +
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#OptChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#OPTTYPE#", ASTNode.java5 ? "Opt<" + getId().type() + ">" : "Opt");
    s = s.replaceAll("#ANNOTATIONS#", ASTNode.suppressWarnings());
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }


  String TokenComponent.setIDComment() {
    return ind + "/**\n" +
      ind + " * Setter for lexeme #ID#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String TokenComponent.getIDComment() {
    return ind + "/**\n" +
      ind + " * Getter for lexeme #ID#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  private boolean TokenComponent.called = false;
  public void TokenComponent.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    StringBuffer buf = new StringBuffer();
    buf.append(setIDComment());
    // Generate attribute, get- and set-method for the token string
    buf.append(
        // ES_2011-09-20: Code generation for incremental evaluation
        (ASTNode.incremental ? jaddGenIncrementalTokenHandler() : "") +
        //
        ind + "public void #HOST#.set#ID#(#TYPE# value) {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "token#TYPEINSIGNATURE#_#ID# = value;\n" +
        // ES_2011-09-20: Code generation for incremental evaluation
        (ASTNode.incremental ? jaddGenIncrementalTokenChange() : "") +
        //
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n"
        );
    if(decl.redefinesTokenComponent(this)) {
      buf.append(ind + "/**");
      buf.append(ind + " * @apilevel internal");
      buf.append(ind + " */");
      buf.append(ind + "protected #TYPE# #HOST#.token#TYPEINSIGNATURE#_#ID#;\n");
    }
    if(!isNTA()) {
      boolean isStringToken = getTokenId().getTYPE().equals("String") || getTokenId().getTYPE().equals("java.lang.String");
      if(isStringToken && ASTNode.beaver) {
        if(decl.redefinesTokenComponent(this)) {
          buf.append(
              ind + "public int #HOST#.#ID#start;\n" +
              ind + "public int #HOST#.#ID#end;\n"
              );
        }
        buf.append(
            ind + "public void #HOST#.set#ID#(beaver.Symbol symbol) {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            ind(2) + "if(symbol.value != null && !(symbol.value instanceof String))\n" +
            ind(3) + "throw new UnsupportedOperationException(\"set#ID# is only valid for String lexemes\");\n" +
            ind(2) + "token#TYPEINSIGNATURE#_#ID# = (String)symbol.value;\n" +
            ind(2) + "#ID#start = symbol.getStart();\n" +
            ind(2) + "#ID#end = symbol.getEnd();\n" +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenChange() : "") + 
            //
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n"
            );
      }
      if(isStringToken)
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenTrack() : "") +
            //
            ind(2) + "return token#TYPEINSIGNATURE#_#ID# != null ? token#TYPEINSIGNATURE#_#ID# : \"\";\n" +
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n");
      else
        buf.append(
            getIDComment() +
            ind + "public #TYPE# #HOST#.get#ID#() {\n" +
            (ASTNode.block ? ASTNode.blockBegin : "") +
            // ES_2011-09-20: Code generation for incremental evaluation, tokens
            (ASTNode.incremental ? jaddGenIncrementalTokenTrack() : "") +
            //
            ind(2) + "return token#TYPEINSIGNATURE#_#ID#;\n" +
            (ASTNode.block ? ASTNode.blockEnd : "") +
            ind + "}\n");
    }
    String s = buf.toString();
    s = s.replaceAll("#ID#", getTokenId().getID());
    s = s.replaceAll("#TYPE#", getTokenId().getTYPE());
    s = s.replaceAll("#TYPEINSIGNATURE#", ASTNode.convTypeNameToSignature(getTokenId().getTYPE()));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);

  }


  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenHandler() {
    if (ASTNode.incrementalLevelParam)
      return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                 "new ASTNode$DepGraphNode(this, \"get#ID#\", null);\n";
    if (ASTNode.incrementalLevelAttr)
      return "    protected ASTNode$DepGraphNode #HOST#.get#ID#_handler = " +
                 "new ASTNode$DepGraphNode(this, \"get#ID#\");\n";
    return ""; // ASTNode.incrementalLevelNode
  }
  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenChange() {
    if (ASTNode.incrementalLevelNode) // TODO: invalidate cache?
      return "        handler.notifyDependencies();";
    return "        get#ID#_handler.notifyDependencies();\n";
  }
  // ES_2011-09-20: Code generation for incremental evaluation
  String TokenComponent.jaddGenIncrementalTokenTrack() {
    if (ASTNode.incrementalLevelParam || ASTNode.incrementalLevelAttr)
      return "        state().addHandlerDepTo(get#ID#_handler);\n";
    return "        state().addHandlerDepTo(handler);\n"; // ASTNode.incrementalLevelNode
  }

  String AggregateComponents.setNameComment() {
    return ind + "/**\n" +
      ind + " * Setter for #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }
  String AggregateComponents.getNameComment() {
    return ind + "/**\n" +
      ind + " * Getter for #NAME#\n" +
      ind + " * @apilevel high-level\n" +
      ind + " */\n";
  }

  public void AggregateComponents.jaddGen(PrintWriter stream, int index, boolean publicModifier, ASTDecl decl) {
    String name = decl.name();
    String s;
    // Generate get-method for component
    s = setNameComment() +
      ind + "public void #HOST#.set#NAME#(#TYPE# node) {\n" + 
      (ASTNode.block ? ASTNode.blockBegin : "") +
      ind(2) + "setChild(node, #INDEX#);\n" + 
      (ASTNode.block ? ASTNode.blockEnd : "") +
      ind + "}\n";
    if(!isNTA()) {
      s +=
        getNameComment() +
        ind + "public #TYPE# #HOST#.get#NAME#() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChild(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" + 
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n";
    }
    else {
      s +=
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "public #TYPE# #HOST#.get#NAME#NoTransform() {\n" +
        (ASTNode.block ? ASTNode.blockBegin : "") +
        ind(2) + "return (#TYPE#)getChildNoTransform(#INDEX#);\n" + 
        (ASTNode.block ? ASTNode.blockEnd : "") +
        ind + "}\n" +
        ind + "/**\n" +
        ind + " * @apilevel low-level\n" +
        ind + " */\n" +
        ind + "protected int #HOST#.get#NAME#ChildPosition() {\n" +
        ind(2) + "return #INDEX#;\n" +
        ind + "}\n";
    }
    s = s.replaceAll("#TYPE#", getId().type());
    s = s.replaceAll("#NAME#", getId().name());
    s = s.replaceAll("#INDEX#", String.valueOf(index));
    s = s.replaceAll("#HOST#", name);
    if(!publicModifier)
      s = s.replaceAll(ind + "public ", ind + "private ");
    //stream.println(s);
    parse(s);
  }

  protected void Components.parse(String s) {
    jrag.AST.JragParser jp = new jrag.AST.JragParser(new java.io.StringReader(s));
    jp.root = hostClass().env();
    jp.setFileName(hostClass().getFileName());

    // EMMA_2011-09-08: Adding this to give .ast generated methods an enclosing 
    // aspect "Ast" which allows for refinement of these methods. For example,
    // "getA" generated from "B ::= A" can be refined using the "Ast" aspect.
    //jp.enclosingAspect = "Ast";

    try {
      while(true)
        jp.AspectBodyDeclaration();
    } catch (Exception e) {
    }
  }
}
